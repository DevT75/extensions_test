{"version":3,"file":"static/js/38.79786f9f.chunk.js","mappings":"wHAMA,MAAMA,EAA6B,IAAIC,IACjCC,EAA8B,IAAID,IAwCjCE,eAAeC,EACpBC,EAAwBC,GAC+C,IAAvE,SAAEC,EAAQ,UAAEC,EAAYC,OAAOC,mBAAwCJ,EAEvE,MAAMK,EAvCF,SAA0BJ,GAC9B,MAAMK,EAAaA,CAAQC,EAAmBF,KAA8B,CAC1EG,MAAOA,IAAMH,EAAMI,OAAOF,GAC1BG,IAAKA,IAAML,EAAMK,IAAIH,GACrBI,IAAMC,GAAgBP,EAAMM,IAAIJ,EAAWK,KAGvCC,EAAUP,EAA2BL,EAAUP,GAC/CoB,EAAWR,EACfL,EACAL,GAGF,MAAO,CACLY,MAAOA,KACLK,EAAQL,QACRM,EAASN,OAAO,EAElBK,UACAC,WAEJ,CAkBgBC,CAAgBd,GAKxBa,EAAWT,EAAMS,SAASJ,MAChC,GAAII,GAAYZ,EAAY,EAAG,CAE7B,IADY,IAAIc,MAAOC,UAAYH,EAASI,QAAQD,UAC1Cf,EACR,OAAOY,EAASF,IAEpB,CAEA,IAAIC,EAAUR,EAAMQ,QAAQH,MACvBG,IACHA,EAAUd,IAIVM,EAAMQ,QAAQF,IAAIE,IAGpB,IACE,MAAMD,QAAaC,EAMnB,OAFAR,EAAMS,SAASH,IAAI,CAAEO,QAAS,IAAIF,KAAQJ,SAEnCA,CACT,CAAE,QAGAP,EAAMQ,QAAQL,OAChB,CACF,C,cC/EO,MAAMW,EAAc,aACrBC,EAAY,GACZC,EAAa,CACjB,CACEC,KAAM,UCOHzB,eAAe0B,EACpBC,GAEA,OAAO1B,GAAU,ID0CZD,eAAwB2B,GAC7B,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACR,EAAaC,EAAWC,GACjCO,OAAQ,IAEZ,CChDyBC,CAAkBL,IAAU,CACjDvB,SAAU,GAAGuB,EAAQE,SAASI,MAAMC,MAAMP,EAAQE,SAASM,mBAE3D9B,UAAWC,OAAOC,mBAEtB,C","sources":["../node_modules/thirdweb/src/utils/promise/withCache.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/decimals.ts","../node_modules/thirdweb/src/extensions/erc20/read/decimals.ts"],"sourcesContent":["// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts\n// with slight adjustments made to comply with our linting rules\n// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing\n// alternatively viem could maybe export this helpful util\n// TODO: explore using a LRU cache instead of a Map\n\nconst promiseCache = /*#__PURE__*/ new Map();\nconst responseCache = /*#__PURE__*/ new Map();\n\n/**\n *@internal\n */\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey_: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey_),\n    get: () => cache.get(cacheKey_),\n    set: (data: TData) => cache.set(cacheKey_, data),\n  });\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache);\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  );\n\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response,\n  };\n}\n\ntype WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string;\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number;\n};\n\n/**\n * Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n * @internal\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, cacheTime = Number.POSITIVE_INFINITY }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey);\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) {\n      return response.data;\n    }\n  }\n\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n\n  try {\n    const data = await promise;\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data });\n\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}\n","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x313ce567\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint8\",\n  },\n] as const;\n\n/**\n * Checks if the `decimals` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `decimals` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isDecimalsSupported } from \"thirdweb/extensions/erc20\";\n * const supported = isDecimalsSupported([\"0x...\"]);\n * ```\n */\nexport function isDecimalsSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the decimals function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeDecimalsResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeDecimalsResultResult(\"...\");\n * ```\n */\nexport function decodeDecimalsResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"decimals\" function on the contract.\n * @param options - The options for the decimals function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const result = await decimals({\n *  contract,\n * });\n *\n * ```\n */\nexport async function decimals(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { decimals as generatedDecimals } from \"../__generated__/IERC20/read/decimals.js\";\n\nexport { isDecimalsSupported } from \"../__generated__/IERC20/read/decimals.js\";\n\n/**\n * Retrieves the number of decimal places for a given ERC20 contract.\n * @param options - The options for the transaction.\n * @returns A promise that resolves to the number of decimal places.\n * @extension ERC20\n * @example\n * ```ts\n * import { decimals } from \"thirdweb/extensions/erc20\";\n *\n * const tokenDecimals = await decimals({ contract });\n * ```\n */\nexport async function decimals(\n  options: BaseTransactionOptions,\n): Promise<number> {\n  return withCache(() => generatedDecimals(options), {\n    cacheKey: `${options.contract.chain.id}:${options.contract.address}:decimals`,\n    // can never change, so cache forever\n    cacheTime: Number.POSITIVE_INFINITY,\n  });\n}\n"],"names":["promiseCache","Map","responseCache","async","withCache","fn","_ref","cacheKey","cacheTime","Number","POSITIVE_INFINITY","cache","buildCache","cacheKey_","clear","delete","get","set","data","promise","response","getCache","Date","getTime","created","FN_SELECTOR","FN_INPUTS","FN_OUTPUTS","type","decimals","options","readContract","contract","method","params","generatedDecimals","chain","id","address"],"sourceRoot":""}