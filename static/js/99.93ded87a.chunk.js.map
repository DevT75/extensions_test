{"version":3,"file":"static/js/99.93ded87a.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/node_modules/viem/utils/formatters/block.ts","../node_modules/thirdweb/src/rpc/actions/eth_getBlockByNumber.ts","../node_modules/thirdweb/src/rpc/actions/eth_maxPriorityFeePerGas.ts","../node_modules/thirdweb/src/gas/get-gas-price.ts","../node_modules/thirdweb/src/rpc/actions/eth_gasPrice.ts","../node_modules/thirdweb/src/gas/fee-data.ts","../node_modules/thirdweb/src/gas/op-gas-fee-reducer.ts","../node_modules/thirdweb/src/transaction/actions/encode.ts","../node_modules/thirdweb/node_modules/viem/utils/formatters/transactionRequest.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/formatAbi.ts","../node_modules/thirdweb/src/extensions/modules/__generated__/IModularCore/read/getInstalledModules.ts","../node_modules/thirdweb/src/utils/ipfs.ts","../node_modules/thirdweb/src/storage/download.ts","../node_modules/thirdweb/src/utils/base58/alphabet.ts","../node_modules/thirdweb/src/utils/base58/encode.ts","../node_modules/thirdweb/src/utils/bytecode/cbor-decode.ts","../node_modules/thirdweb/src/utils/bytecode/extractIPFS.ts","../node_modules/thirdweb/src/utils/bytecode/prefix.ts","../node_modules/thirdweb/src/contract/actions/resolve-abi.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/parseAbi.ts","../node_modules/thirdweb/src/transaction/extract-error.ts","../node_modules/thirdweb/src/transaction/actions/estimate-gas.ts","../node_modules/thirdweb/src/transaction/actions/to-serializable-transaction.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/toRlp.ts","../node_modules/thirdweb/src/utils/bigint.ts","../node_modules/@noble/hashes/src/_md.ts","../node_modules/@noble/hashes/src/sha256.ts","../node_modules/thirdweb/node_modules/viem/zksync/constants/number.ts","../node_modules/thirdweb/node_modules/viem/zksync/errors/bytecode.ts","../node_modules/thirdweb/node_modules/viem/zksync/utils/hashBytecode.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/sha256.ts","../node_modules/thirdweb/src/transaction/actions/zksync/getEip721Domain.ts","../node_modules/thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts","../node_modules/thirdweb/src/rpc/actions/eth_sendRawTransaction.ts","../node_modules/thirdweb/src/transaction/prepare-transaction.ts","../node_modules/thirdweb/src/transaction/read-contract.ts","../node_modules/thirdweb/src/rpc/actions/eth_call.ts","../node_modules/thirdweb/src/transaction/utils.ts","../node_modules/thirdweb/src/utils/abi/encodeAbiParameters.ts","../node_modules/thirdweb/src/utils/abi/prepare-method.ts","../node_modules/thirdweb/src/utils/encoding/helpers/concat-hex.ts","../node_modules/thirdweb/src/utils/promise/resolve-promised-value.ts","../node_modules/thirdweb/src/utils/units.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/allowance.ts","../node_modules/thirdweb/src/transaction/prepare-contract-call.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/write/approve.ts","../node_modules/thirdweb/src/extensions/erc20/write/approve.ts","../node_modules/thirdweb/src/utils/promise/once.ts","../node_modules/thirdweb/src/utils/signatures/helpers/parseTypedData.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/toEventSelector.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/decodeEventLog.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/getAbiItem.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/parseEventLogs.ts","../node_modules/thirdweb/node_modules/viem/utils/address/isAddressEqual.ts","../node_modules/thirdweb/node_modules/viem/errors/log.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/encodeEventTopics.ts","../node_modules/thirdweb/src/event/prepare-event.ts","../node_modules/thirdweb/src/event/utils.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.ts","../node_modules/thirdweb/src/wallets/smart/lib/utils.ts","../node_modules/thirdweb/src/wallets/smart/lib/bundler.ts","../node_modules/thirdweb/src/wallets/smart/types.ts","../node_modules/thirdweb/src/event/actions/parse-logs.ts","../node_modules/thirdweb/src/wallets/smart/lib/calls.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getNonce.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.ts","../node_modules/thirdweb/src/wallets/smart/lib/packUserOp.ts","../node_modules/thirdweb/src/wallets/smart/lib/paymaster.ts","../node_modules/thirdweb/src/wallets/smart/lib/userop.ts","../node_modules/thirdweb/src/wallets/smart/index.ts","../node_modules/thirdweb/src/utils/any-evm/zksync/isZkSyncChain.ts","../node_modules/thirdweb/node_modules/abitype/src/errors.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/errors/abiItem.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/errors/abiParameter.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/errors/signature.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/formatAbiParameter.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/formatAbiParameters.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/formatAbiItem.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/parseAbiItem.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/runtime/signatures.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/errors/struct.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/runtime/structs.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/errors/splitParameters.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/runtime/cache.ts","../node_modules/thirdweb/node_modules/abitype/src/human-readable/runtime/utils.ts","../node_modules/thirdweb/node_modules/abitype/src/regex.ts","../node_modules/thirdweb/node_modules/viem/constants/number.ts","../node_modules/thirdweb/node_modules/viem/errors/abi.ts","../node_modules/thirdweb/node_modules/viem/errors/address.ts","../node_modules/thirdweb/node_modules/viem/errors/cursor.ts","../node_modules/thirdweb/node_modules/viem/errors/data.ts","../node_modules/thirdweb/node_modules/viem/utils/data/trim.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/fromBytes.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/decodeAbiParameters.ts","../node_modules/thirdweb/node_modules/viem/constants/solidity.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/decodeErrorResult.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/encodeAbiParameters.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/formatAbiItem.ts","../node_modules/thirdweb/node_modules/viem/utils/address/getAddress.ts","../node_modules/thirdweb/node_modules/viem/utils/address/isAddress.ts","../node_modules/thirdweb/node_modules/viem/utils/cursor.ts","../node_modules/thirdweb/node_modules/viem/utils/data/concat.ts","../node_modules/thirdweb/node_modules/viem/utils/data/pad.ts","../node_modules/thirdweb/node_modules/viem/utils/data/slice.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/toBytes.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/toHex.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/keccak256.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/toFunctionSelector.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/hashSignature.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/toSignature.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/normalizeSignature.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/toSignatureHash.ts","../node_modules/thirdweb/node_modules/viem/utils/lru.ts","../node_modules/thirdweb/node_modules/viem/utils/regex.ts","../node_modules/thirdweb/node_modules/viem/utils/typedData.ts","../node_modules/thirdweb/node_modules/viem/utils/signature/hashTypedData.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ExtractChainFormatterExclude,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { type FormattedTransaction, formatTransaction } from './transaction.js'\n\ntype BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'\n\nexport type FormattedBlock<\n  chain extends Chain | undefined = undefined,\n  includeTransactions extends boolean = boolean,\n  blockTag extends BlockTag = BlockTag,\n  _FormatterReturnType = ExtractChainFormatterReturnType<\n    chain,\n    'block',\n    Block<bigint, includeTransactions>\n  >,\n  _ExcludedPendingDependencies extends string = BlockPendingDependencies &\n    ExtractChainFormatterExclude<chain, 'block'>,\n  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {\n    [_key in _ExcludedPendingDependencies]: never\n  } & Pick<\n      Block<bigint, includeTransactions, blockTag>,\n      BlockPendingDependencies\n    >,\n  _Transactions = includeTransactions extends true\n    ? Prettify<FormattedTransaction<chain, blockTag>>[]\n    : Hash[],\n> = Omit<_Formatted, 'transactions'> & {\n  transactions: _Transactions\n}\n\nexport type FormatBlockErrorType = ErrorType\n\nexport function formatBlock(block: ExactPartial<RpcBlock>) {\n  const transactions = block.transactions?.map((transaction) => {\n    if (typeof transaction === 'string') return transaction\n    return formatTransaction(transaction)\n  })\n  return {\n    ...block,\n    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\n    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,\n    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,\n    excessBlobGas: block.excessBlobGas\n      ? BigInt(block.excessBlobGas)\n      : undefined,\n    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,\n    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,\n    hash: block.hash ? block.hash : null,\n    logsBloom: block.logsBloom ? block.logsBloom : null,\n    nonce: block.nonce ? block.nonce : null,\n    number: block.number ? BigInt(block.number) : null,\n    size: block.size ? BigInt(block.size) : undefined,\n    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,\n    transactions,\n    totalDifficulty: block.totalDifficulty\n      ? BigInt(block.totalDifficulty)\n      : null,\n  } as Block\n}\n\nexport type DefineBlockErrorType = DefineFormatterErrorType | ErrorType\n\nexport const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)\n","import {\n  type BlockTag,\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type GetBlockReturnType,\n  formatBlock,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype GetBlockParameters<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = \"latest\",\n> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint;\n      blockTag?: never;\n    }\n  | {\n      blockNumber?: never;\n      /**\n       * The block tag.\n       * default: 'latest'\n       */\n      blockTag?: TBlockTag | BlockTag;\n    }\n);\n\n/**\n * Retrieves a block by its number or tag from the Ethereum blockchain.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the block.\n * @returns A promise that resolves to the requested block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByNumber } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByNumber(rpcRequest, {\n *  blockNumber: 123456,\n *  includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByNumber<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = \"latest\",\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockParameters<TIncludeTransactions, TBlockTag>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions, TBlockTag>> {\n  const blockTag = params.blockTag ?? \"latest\";\n  const includeTransactions = params.includeTransactions ?? false;\n  const blockNumberHex =\n    params.blockNumber !== undefined\n      ? numberToHex(params.blockNumber)\n      : undefined;\n\n  const block = await request({\n    method: \"eth_getBlockByNumber\",\n    params: [blockNumberHex || blockTag, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions,\n    TBlockTag\n  >;\n}\n","import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the maximum priority fee per gas from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to a bigint representing the maximum priority fee per gas.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_maxPriorityFeePerGas } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const maxPriorityFeePerGas = await eth_maxPriorityFeePerGas(rpcRequest);\n * ```\n */\nexport async function eth_maxPriorityFeePerGas(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_maxPriorityFeePerGas\",\n  });\n  return hexToBigInt(result);\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_gasPrice } from \"../rpc/actions/eth_gasPrice.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\n\nexport type GetGasPriceOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  percentMultiplier?: number;\n};\n\n/**\n * Retrieves the gas price for a transaction on a specific chain.\n * @param client - The Thirdweb client.\n * @param chain - The ID of the chain.\n * @returns A promise that resolves to the gas price as a bigint.\n * @example\n * ```ts\n * import { getGasPrice } from \"thirdweb\";\n *\n * const gasPrice = await getGasPrice({ client, chain });\n * ```\n * @utils\n */\nexport async function getGasPrice(\n  options: GetGasPriceOptions,\n): Promise<bigint> {\n  const { client, chain, percentMultiplier } = options;\n  const rpcClient = getRpcClient({ client, chain });\n  const gasPrice_ = await eth_gasPrice(rpcClient);\n  const extraTip = percentMultiplier\n    ? (gasPrice_ / BigInt(100)) * BigInt(percentMultiplier)\n    : 0n;\n  const txGasPrice = gasPrice_ + extraTip;\n  return txGasPrice;\n}\n","import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current gas price from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the gas price as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_gasPrice } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const gasPrice = await eth_gasPrice(rpcRequest);\n * ```\n */\nexport async function eth_gasPrice(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_gasPrice\",\n  });\n  return hexToBigInt(result);\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_getBlockByNumber } from \"../rpc/actions/eth_getBlockByNumber.js\";\nimport { eth_maxPriorityFeePerGas } from \"../rpc/actions/eth_maxPriorityFeePerGas.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport { toUnits } from \"../utils/units.js\";\nimport { getGasPrice } from \"./get-gas-price.js\";\nimport { roundUpGas } from \"./op-gas-fee-reducer.js\";\n\ntype FeeData = {\n  maxFeePerGas: null | bigint;\n  maxPriorityFeePerGas: null | bigint;\n};\n\ntype FeeDataParams =\n  | {\n      gasPrice?: never;\n      maxFeePerGas?: bigint;\n      maxPriorityFeePerGas?: bigint;\n    }\n  | {\n      gasPrice?: bigint;\n      maxFeePerGas?: never;\n      maxPriorityFeePerGas?: never;\n    };\n\n// for these chains - always force pre eip1559 transactions\nconst FORCE_GAS_PRICE_CHAIN_IDS = [\n  78600, // Vanar testnet\n  2040, // Vanar mainnet\n  248, // Oasys Mainnet\n  9372, // Oasys Testnet\n  841, // Taraxa Mainnet\n  842, // Taraxa Testnet\n  2016, // MainnetZ Mainnet\n  9768, // MainnetZ Testnet\n];\n\n/**\n *\n * @internal\n */\nexport async function getGasOverridesForTransaction(\n  transaction: PreparedTransaction,\n): Promise<FeeDataParams> {\n  // first check for explicit values\n  const [maxFeePerGas, maxPriorityFeePerGas, gasPrice] = await Promise.all([\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.gasPrice),\n  ]);\n\n  // Exit early if the user explicitly provided enough options\n  if (maxFeePerGas !== undefined && maxPriorityFeePerGas !== undefined) {\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n  if (gasPrice) {\n    return { gasPrice };\n  }\n\n  // If we don't have enough explicit values, get defaults\n  const defaultGasOverrides = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n  );\n\n  if (transaction.chain.experimental?.increaseZeroByteCount) {\n    // otherwise adjust each value\n    if (defaultGasOverrides.gasPrice) {\n      return { gasPrice: roundUpGas(defaultGasOverrides.gasPrice) };\n    }\n\n    return {\n      maxFeePerGas:\n        maxFeePerGas ?? roundUpGas(defaultGasOverrides.maxFeePerGas ?? 0n),\n      maxPriorityFeePerGas:\n        maxPriorityFeePerGas ??\n        roundUpGas(defaultGasOverrides.maxPriorityFeePerGas ?? 0n),\n    };\n  }\n\n  // return as is\n  if (defaultGasOverrides.gasPrice) {\n    return defaultGasOverrides;\n  }\n\n  // Still check for explicit values in case one is provided and not the other\n  return {\n    maxFeePerGas: maxFeePerGas ?? defaultGasOverrides.maxFeePerGas,\n    maxPriorityFeePerGas:\n      maxPriorityFeePerGas ?? defaultGasOverrides.maxPriorityFeePerGas,\n  };\n}\n\n/**\n * Retrieves the default gas overrides for a given client and chain ID.\n * If the fee data contains both maxFeePerGas and maxPriorityFeePerGas, it returns an object with those values.\n * Otherwise, it returns an object with the gasPrice obtained from the client and chain ID.\n * @param client - The ThirdwebClient instance.\n * @param chain - The chain ID.\n * @returns An object containing the default gas overrides.\n * @internal\n */\nexport async function getDefaultGasOverrides(\n  client: ThirdwebClient,\n  chain: Chain,\n) {\n  // if chain is in the force gas price list, always use gas price\n  if (!FORCE_GAS_PRICE_CHAIN_IDS.includes(chain.id)) {\n    const feeData = await getDynamicFeeData(client, chain);\n    if (\n      feeData.maxFeePerGas !== null &&\n      feeData.maxPriorityFeePerGas !== null\n    ) {\n      return {\n        maxFeePerGas: feeData.maxFeePerGas,\n        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,\n      };\n    }\n  }\n  return {\n    gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 }),\n  };\n}\n\n/**\n * Retrieves dynamic fee data for a given chain.\n * @param client - The Thirdweb client.\n * @param chain - The chain ID.\n * @returns A promise that resolves to the fee data.\n * @internal\n */\nasync function getDynamicFeeData(\n  client: ThirdwebClient,\n  chain: Chain,\n): Promise<FeeData> {\n  let maxFeePerGas: null | bigint = null;\n  let maxPriorityFeePerGas_: null | bigint = null;\n\n  const rpcRequest = getRpcClient({ client, chain });\n\n  const [block, maxPriorityFeePerGas] = await Promise.all([\n    eth_getBlockByNumber(rpcRequest, { blockTag: \"latest\" }),\n    eth_maxPriorityFeePerGas(rpcRequest).catch(() => null),\n  ]);\n\n  const baseBlockFee = block?.baseFeePerGas ?? 0n;\n\n  const chainId = chain.id;\n  // flag chain testnet & flag chain\n  if (chainId === 220 || chainId === 1220) {\n    // these does not support eip-1559, for some reason even though `eth_maxPriorityFeePerGas` is available?!?\n    // return null because otherwise TX break\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n    // mumbai & polygon\n  }\n  if (chainId === 80002 || chainId === 137) {\n    // for polygon, get fee data from gas station\n    maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);\n  } else if (maxPriorityFeePerGas !== null) {\n    // prioritize fee from eth_maxPriorityFeePerGas\n    maxPriorityFeePerGas_ = maxPriorityFeePerGas;\n  }\n\n  if (maxPriorityFeePerGas_ == null) {\n    // chain does not support eip-1559, return null for both\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n  }\n\n  // add 10% tip to maxPriorityFeePerGas for faster processing\n  maxPriorityFeePerGas_ = getPreferredPriorityFee(maxPriorityFeePerGas_);\n  // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is\n  // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees\n  maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;\n\n  // special cased for Celo gas fees\n  if (chainId === 42220 || chainId === 44787 || chainId === 62320) {\n    maxPriorityFeePerGas_ = maxFeePerGas;\n  }\n\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas_,\n  };\n}\n\n/**\n * Calculates the preferred priority fee based on the default priority fee per gas and a percent multiplier.\n * @param defaultPriorityFeePerGas - The default priority fee per gas.\n * @param percentMultiplier - The percent multiplier to calculate the extra tip. Default is 10.\n * @returns The total priority fee including the extra tip.\n * @internal\n */\nfunction getPreferredPriorityFee(\n  defaultPriorityFeePerGas: bigint,\n  percentMultiplier = 10,\n): bigint {\n  const extraTip =\n    (defaultPriorityFeePerGas / BigInt(100)) * BigInt(percentMultiplier);\n  const totalPriorityFee = defaultPriorityFeePerGas + extraTip;\n  return totalPriorityFee;\n}\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId: 137 | 80002): string {\n  switch (chainId) {\n    case 137:\n      return \"https://gasstation.polygon.technology/v2\";\n    case 80002:\n      return \"https://gasstation-testnet.polygon.technology/v2\";\n  }\n}\n\nconst MIN_POLYGON_GAS_PRICE = 31n; // 31 gwei\n\n/**\n *\n * @returns The gas price\n * @internal\n */\nasync function getPolygonGasPriorityFee(chainId: 137 | 80002): Promise<bigint> {\n  const gasStationUrl = getGasStationUrl(chainId);\n  try {\n    const data = await (await fetch(gasStationUrl)).json();\n    // take the standard speed here, SDK options will define the extra tip\n    const priorityFee = data.fast.maxPriorityFee;\n    if (priorityFee > 0) {\n      const fixedFee = Number.parseFloat(priorityFee).toFixed(9);\n      return toUnits(fixedFee, 9);\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return MIN_POLYGON_GAS_PRICE;\n}\n","/**\n * Via: https://twitter.com/0xjustadev/status/1758973668011434062\n *\n * Increases the gas fee value to the nearest power of 2.\n * If the value is already a power of 2 or 0, it returns the value as is.\n * Otherwise, it finds the highest power of 2 that is bigger than the given value.\n * @param value - The gas fee value to be \"rounded up\".\n * @returns The *increased* gas value which will result in a lower L1 gas fee, overall reducing the gas fee.\n * @internal\n */\nexport function roundUpGas(value: bigint): bigint {\n  if (value === 0n || (value & (value - 1n)) === 0n) {\n    return value;\n  }\n\n  // Find the highest set bit by shifting until the value is 0.\n  let highestBit = 1n;\n  while (value > 0n) {\n    // biome-ignore lint/style/noParameterAssign: the whole point is that we modify the value in palce\n    value >>= 1n;\n    highestBit <<= 1n;\n  }\n\n  return highestBit;\n}\n","import type { Abi, AbiFunction } from \"abitype\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nconst encodeWeakMap = new WeakMap<\n  PreparedTransaction<Abi, AbiFunction>,\n  Promise<Hex>\n>();\n\n/**\n * Encodes a transaction object into a hexadecimal string representation of the encoded data.\n * @param transaction - The transaction object to encode.\n * @returns A promise that resolves to the encoded data as a hexadecimal string.\n * @transaction\n * @example\n * ```ts\n * import { encode } from \"thirdweb\";\n * const encodedData = await encode(transaction);\n * ```\n */\nexport async function encode<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (encodeWeakMap.has(transaction)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return encodeWeakMap.get(transaction)!;\n  }\n  const promise = (async () => {\n    const [data, extraData, { concatHex }] = await Promise.all([\n      getDataFromTx(transaction),\n      getExtraCallDataFromTx(transaction),\n      import(\"../../utils/encoding/helpers/concat-hex.js\"),\n    ]);\n    if (extraData) {\n      return concatHex([data, extraData]);\n    }\n    return data;\n  })();\n  encodeWeakMap.set(transaction, promise);\n  return promise;\n}\n\n/**\n * Get the transaction.data (from a PreparedTransaction)\n * If the transaction does not have `data`, we default to \"0x\"\n * @internal\n */\nexport async function getDataFromTx<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (transaction.data === undefined) {\n    return \"0x\";\n  }\n  if (typeof transaction.data === \"function\") {\n    const data = await transaction.data();\n    if (!data) {\n      return \"0x\";\n    }\n    return data;\n  }\n  return transaction.data;\n}\n\n/**\n * Get the extraCallData from a PreparedTransaction\n * @internal\n * If extraCallData is \"0x\", we will return `undefined`\n * to simplify the code, since concatenating \"0x\" doesn't do anything\n */\nexport async function getExtraCallDataFromTx<\n  abi extends Abi,\n  abiFn extends AbiFunction,\n>(transaction: PreparedTransaction<abi, abiFn>): Promise<Hex | undefined> {\n  if (!transaction.extraCallData) {\n    return undefined;\n  }\n  if (typeof transaction.extraCallData === \"function\") {\n    const extraData = await transaction.extraCallData();\n    if (!extraData) return undefined;\n    if (!extraData.startsWith(\"0x\")) {\n      throw Error(\"Invalid extra calldata - must be a hex string\");\n    }\n    if (extraData === \"0x\") {\n      return undefined;\n    }\n    return extraData;\n  }\n  if (!transaction.extraCallData.startsWith(\"0x\")) {\n    throw Error(\"Invalid extra calldata - must be a hex string\");\n  }\n  return transaction.extraCallData;\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { AuthorizationList } from '../../experimental/eip7702/types/authorization.js'\nimport type { RpcAuthorizationList } from '../../experimental/eip7702/types/rpc.js'\nimport type {\n  Chain,\n  ExtractChainFormatterParameters,\n} from '../../types/chain.js'\nimport type { ByteArray } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { bytesToHex, numberToHex } from '../encoding/toHex.js'\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\n\nexport type FormattedTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n> = ExtractChainFormatterParameters<\n  chain,\n  'transactionRequest',\n  TransactionRequest\n>\n\nexport const rpcTransactionType = {\n  legacy: '0x0',\n  eip2930: '0x1',\n  eip1559: '0x2',\n  eip4844: '0x3',\n  eip7702: '0x4',\n} as const\n\nexport type FormatTransactionRequestErrorType = ErrorType\n\nexport function formatTransactionRequest(\n  request: ExactPartial<TransactionRequest>,\n) {\n  const rpcRequest = {} as RpcTransactionRequest\n\n  if (typeof request.authorizationList !== 'undefined')\n    rpcRequest.authorizationList = formatAuthorizationList(\n      request.authorizationList,\n    )\n  if (typeof request.accessList !== 'undefined')\n    rpcRequest.accessList = request.accessList\n  if (typeof request.blobVersionedHashes !== 'undefined')\n    rpcRequest.blobVersionedHashes = request.blobVersionedHashes\n  if (typeof request.blobs !== 'undefined') {\n    if (typeof request.blobs[0] !== 'string')\n      rpcRequest.blobs = (request.blobs as ByteArray[]).map((x) =>\n        bytesToHex(x),\n      )\n    else rpcRequest.blobs = request.blobs\n  }\n  if (typeof request.data !== 'undefined') rpcRequest.data = request.data\n  if (typeof request.from !== 'undefined') rpcRequest.from = request.from\n  if (typeof request.gas !== 'undefined')\n    rpcRequest.gas = numberToHex(request.gas)\n  if (typeof request.gasPrice !== 'undefined')\n    rpcRequest.gasPrice = numberToHex(request.gasPrice)\n  if (typeof request.maxFeePerBlobGas !== 'undefined')\n    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas)\n  if (typeof request.maxFeePerGas !== 'undefined')\n    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    rpcRequest.nonce = numberToHex(request.nonce)\n  if (typeof request.to !== 'undefined') rpcRequest.to = request.to\n  if (typeof request.type !== 'undefined')\n    rpcRequest.type = rpcTransactionType[request.type]\n  if (typeof request.value !== 'undefined')\n    rpcRequest.value = numberToHex(request.value)\n\n  return rpcRequest\n}\n\nexport type DefineTransactionRequestErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionRequest = /*#__PURE__*/ defineFormatter(\n  'transactionRequest',\n  formatTransactionRequest,\n)\n\n//////////////////////////////////////////////////////////////////////////////\n\nfunction formatAuthorizationList(\n  authorizationList: AuthorizationList<number, boolean>,\n): RpcAuthorizationList {\n  return authorizationList.map(\n    (authorization) =>\n      ({\n        address: authorization.contractAddress,\n        r: authorization.r,\n        s: authorization.s,\n        chainId: numberToHex(authorization.chainId),\n        nonce: numberToHex(authorization.nonce),\n        ...(typeof authorization.yParity !== 'undefined'\n          ? { yParity: numberToHex(authorization.yParity) }\n          : {}),\n        ...(typeof authorization.v !== 'undefined' &&\n        typeof authorization.yParity === 'undefined'\n          ? { v: numberToHex(authorization.v) }\n          : {}),\n      }) as any,\n  ) as RpcAuthorizationList\n}\n","import type { Abi } from '../abi.js'\nimport { type FormatAbiItem, formatAbiItem } from './formatAbiItem.js'\n\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */\nexport type FormatAbi<abi extends Abi | readonly unknown[]> = Abi extends abi\n  ? readonly string[]\n  : abi extends readonly []\n    ? never\n    : abi extends Abi\n      ? {\n          [key in keyof abi]: FormatAbiItem<abi[key]>\n        }\n      : readonly string[]\n\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */\nexport function formatAbi<const abi extends Abi | readonly unknown[]>(\n  abi: abi,\n): FormatAbi<abi> {\n  const signatures = []\n  const length = abi.length\n  for (let i = 0; i < length; i++) {\n    const abiItem = abi[i]!\n    const signature = formatAbiItem(abiItem as Abi[number])\n    signatures.push(signature)\n  }\n  return signatures as unknown as FormatAbi<abi>\n}\n","import { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\n\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\nexport const FN_SELECTOR = \"0x3e429396\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"tuple[]\",\n    components: [\n      {\n        type: \"address\",\n        name: \"implementation\",\n      },\n      {\n        type: \"tuple\",\n        name: \"config\",\n        components: [\n          {\n            type: \"bool\",\n            name: \"registerInstallationCallback\",\n          },\n          {\n            type: \"bytes4[]\",\n            name: \"requiredInterfaces\",\n          },\n          {\n            type: \"bytes4[]\",\n            name: \"supportedInterfaces\",\n          },\n          {\n            type: \"tuple[]\",\n            name: \"callbackFunctions\",\n            components: [\n              {\n                type: \"bytes4\",\n                name: \"selector\",\n              },\n            ],\n          },\n          {\n            type: \"tuple[]\",\n            name: \"fallbackFunctions\",\n            components: [\n              {\n                type: \"bytes4\",\n                name: \"selector\",\n              },\n              {\n                type: \"uint256\",\n                name: \"permissionBits\",\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  },\n] as const;\n\n/**\n * Checks if the `getInstalledModules` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getInstalledModules` method is supported.\n * @extension MODULES\n * @example\n * ```ts\n * import { isGetInstalledModulesSupported } from \"thirdweb/extensions/modules\";\n * const supported = isGetInstalledModulesSupported([\"0x...\"]);\n * ```\n */\nexport function isGetInstalledModulesSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the getInstalledModules function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension MODULES\n * @example\n * ```ts\n * import { decodeGetInstalledModulesResult } from \"thirdweb/extensions/modules\";\n * const result = decodeGetInstalledModulesResultResult(\"...\");\n * ```\n */\nexport function decodeGetInstalledModulesResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getInstalledModules\" function on the contract.\n * @param options - The options for the getInstalledModules function.\n * @returns The parsed result of the function call.\n * @extension MODULES\n * @example\n * ```ts\n * import { getInstalledModules } from \"thirdweb/extensions/modules\";\n *\n * const result = await getInstalledModules({\n *  contract,\n * });\n *\n * ```\n */\nexport async function getInstalledModules(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import type { ThirdwebClient } from \"../client/client.js\";\nimport type { FileOrBufferOrString } from \"../storage/upload/types.js\";\n\nexport type ResolveSchemeOptions = {\n  client: ThirdwebClient;\n  uri: string;\n};\n\nconst DEFAULT_GATEWAY = \"https://{clientId}.ipfscdn.io/ipfs/{cid}\";\n\n/**\n * Resolves the scheme of a given URI and returns the corresponding URL.\n * If the URI starts with \"ipfs://\", it constructs a URL using the IPFS client ID and the IPFS gateway.\n * If the URI starts with \"http\", it returns the URI as is.\n * Otherwise, it throws an error indicating an invalid URI scheme.\n * @param options - The options object containing the URI and the IPFS client.\n * @returns The resolved URL.\n * @throws Error if the URI scheme is invalid.\n * @example\n * ```ts\n * import { resolveScheme } from \"thirdweb/storage\";\n * const url = resolveScheme({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n * @storage\n */\nexport function resolveScheme(options: ResolveSchemeOptions) {\n  if (options.uri.startsWith(\"ipfs://\")) {\n    const gateway =\n      options.client.config?.storage?.gatewayUrl ?? DEFAULT_GATEWAY;\n    const clientId = options.client.clientId;\n    const cid = findIPFSCidFromUri(options.uri);\n\n    let bundleId: string | undefined = undefined;\n    if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n      // shims use wallet connect RN module which injects Application info in globalThis\n      // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n      bundleId = (globalThis as any).Application.applicationId;\n    }\n\n    // purposefully using SPLIT here and not replace for CID to avoid cases where users don't know the schema\n    // also only splitting on `/ipfs` to avoid cases where people pass non `/` terminated gateway urls\n    return `${\n      gateway.replace(\"{clientId}\", clientId).split(\"/ipfs\")[0]\n    }/ipfs/${cid}${bundleId ? `?bundleId=${bundleId}` : \"\"}`;\n  }\n  if (options.uri.startsWith(\"http\")) {\n    return options.uri;\n  }\n  throw new Error(`Invalid URI scheme, expected \"ipfs://\" or \"http(s)://\"`);\n}\n\n/**\n * @internal\n */\nexport function findIPFSCidFromUri(uri: string) {\n  if (!uri.startsWith(\"ipfs://\")) {\n    // do not touch URIs that are not ipfs URIs\n    return uri;\n  }\n\n  // first index of `/Qm` or `/bafy` in the uri (case insensitive)\n  const firstIndex = uri.search(/\\/(Qm|baf)/i);\n  // we start one character after the first `/` to avoid including it in the CID\n  return uri.slice(firstIndex + 1);\n}\n/**\n * Uploads or extracts URIs from the given files.\n * @template T - The type of the files (File, Buffer, String).\n * @param files - The files to upload or extract URIs from.\n * @param client - The Thirdweb client.\n * @param [startNumber] - The starting number for rewriting file names.\n * @returns - A promise that resolves to an array of URIs.\n * @throws {Error} - If the files are not all of the same type (all URI or all FileOrBufferOrString).\n * @internal\n *\n */\nexport async function uploadOrExtractURIs<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(files: T[], client: ThirdwebClient, startNumber?: number): Promise<string[]> {\n  if (isUriList(files)) {\n    return files;\n  }\n  if (isMetadataList(files)) {\n    const { upload } = await import(\"../storage/upload.js\");\n    const uris = await upload({\n      client,\n      files,\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0,\n      },\n    });\n    return Array.isArray(uris) ? uris : [uris];\n  }\n  throw new Error(\n    \"Files must all be of the same type (all URI or all FileOrBufferOrString)\",\n  );\n}\n\n/**\n * Retrieves the base URI from a batch of URIs.\n *\n * @param uris - An array of URIs.\n * @returns The base URI shared by all URIs in the batch.\n * @throws If the batch contains URIs with different base URIs or if no base URI is found.\n * @internal\n */\nexport function getBaseUriFromBatch(uris: string[]): string {\n  const [base, ...rest] = uris.map((uri) => {\n    // remove query parameters\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"?\") as [string];\n    // remove fragments\n    // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n    [uri] = uri.split(\"#\") as [string];\n\n    // if the URI ends with a `/`, remove it\n    if (uri.endsWith(\"/\")) {\n      // biome-ignore lint/style/noParameterAssign: lemme do my stuff\n      uri = uri.slice(0, -1);\n    }\n\n    // remove the last part of the URI & add the trailing `/`\n    return `${uri.split(\"/\").slice(0, -1).join(\"/\")}/`;\n  });\n\n  if (!base) {\n    throw new Error(\"Batch of URIs is empty\");\n  }\n\n  if (rest.some((uri) => uri !== base)) {\n    throw new Error(\"All URIs in the batch must have the same base URI\");\n  }\n  return base;\n}\n\nfunction isUriList<T extends FileOrBufferOrString | Record<string, unknown>>(\n  metadatas: (string | T)[],\n): metadatas is string[] {\n  return metadatas.every((m) => typeof m === \"string\");\n}\n\nfunction isMetadataList<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(metadatas: (string | T)[]): metadatas is T[] {\n  return metadatas.every((m) => typeof m !== \"string\");\n}\n","import { getClientFetch } from \"../utils/fetch.js\";\nimport { type ResolveSchemeOptions, resolveScheme } from \"../utils/ipfs.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\nexport type DownloadOptions = Prettify<\n  ResolveSchemeOptions & {\n    requestTimeoutMs?: number;\n  }\n>;\n\n/**\n * @description Downloads a file from the specified IPFS, Arweave, or HTTP URI.\n *\n * `download` will parse the provided URI based on its scheme (ipfs://, ar://, https://) and convert it to a URL to fetch the file from thirdweb's storage service.\n *\n * @param options - The download options.\n * @param options.client - The Thirdweb client. See [createThirdwebClient](https://portal.thirdweb.com/references/typescript/v5/createThirdwebClient).\n * @param options.uri - The URI of the file to download. Can be IPFS, Arweave, or HTTP.\n * @param [options.requestTimeoutMs] - The maximum time in milliseconds to wait for the request to complete. Defaults to 60 seconds (60,000 milliseconds).\n *\n * @returns Asynchronously returns the network response from fetching the file.\n * @throws An error if the URI scheme is invalid or if the request fails.\n *\n * @example\n * Download a file from IPFS:\n * ```ts\n * import { download } from \"thirdweb/storage\";\n * import { createThirdwebClient } from \"@thirdweb-dev/sdk\";\n *\n * const client = createThirdwebClient({ clientId: \"YOUR_CLIENT_ID\" });\n *\n * const file = await download({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n *\n * Download a file from Arweave:\n * ```ts\n * import { download } from \"thirdweb/storage\";\n * import { createThirdwebClient } from \"@thirdweb-dev/sdk\";\n *\n * const client = createThirdwebClient({ clientId: \"YOUR_CLIENT_ID\" });\n *\n * const file = await download({\n *  client,\n *  uri: \"ar://{arweave-transaction-id}\",\n * });\n * ```\n *\n * Download a file from HTTP:\n * ```ts\n * import { download } from \"thirdweb/storage\";\n * import { createThirdwebClient } from \"@thirdweb-dev/sdk\";\n *\n * const client = createThirdwebClient({ clientId: \"YOUR_CLIENT_ID\" });\n *\n * const file = await download({\n *  client,\n *  uri: \"https://example.com/file.txt\",\n * });\n * ```\n *\n * @storage\n */\nexport async function download(options: DownloadOptions) {\n  let url: string;\n  if (options.uri.startsWith(\"ar://\")) {\n    const { resolveArweaveScheme } = await import(\"../utils/arweave.js\");\n    url = resolveArweaveScheme(options);\n  } else {\n    url = resolveScheme(options);\n  }\n\n  const res = await getClientFetch(options.client)(url, {\n    keepalive: options.client.config?.storage?.fetch?.keepalive,\n    headers: options.client.config?.storage?.fetch?.headers,\n    requestTimeoutMs:\n      options.client.config?.storage?.fetch?.requestTimeoutMs ?? 60000,\n  });\n\n  if (!res.ok) {\n    res.body?.cancel();\n    throw new Error(`Failed to download file: ${res.statusText}`);\n  }\n  return res;\n}\n","export const ALPHABET =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" as const;\n","import { ALPHABET } from \"./alphabet.js\";\n\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source: Uint8Array): string {\n  if (!(source instanceof Uint8Array)) {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n  if (source.length === 0) {\n    return \"\";\n  }\n  // Skip & count leading zeroes.\n  let zeroes = 0;\n  let length = 0;\n  let pbegin = 0;\n  const pend = source.length;\n  while (pbegin !== pend && source[pbegin] === 0) {\n    pbegin++;\n    zeroes++;\n  }\n  // Allocate enough space in big-endian base58 representation.\n  const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n  const b58 = new Uint8Array(size);\n  // Process the bytes.\n  while (pbegin !== pend) {\n    let carry = source[pbegin] || 0;\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (\n      let it1 = size - 1;\n      (carry !== 0 || i < length) && it1 !== -1;\n      it1--, i++\n    ) {\n      carry += (256 * (b58[it1] || 0)) >>> 0;\n      b58[it1] = (carry % BASE) >>> 0;\n      carry = (carry / BASE) >>> 0;\n    }\n    if (carry !== 0) {\n      throw new Error(\"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n  // Skip leading zeroes in base58 result.\n  let it2 = size - length;\n  while (it2 !== size && b58[it2] === 0) {\n    it2++;\n  }\n  // Translate the result into a string.\n  let str = LEADER.repeat(zeroes);\n  for (; it2 < size; ++it2) {\n    str += ALPHABET.charAt(b58[it2] || 0);\n  }\n  return str;\n}\n","// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n\n// TODO: re-enable typescript and properly type this\n\n// @ts-nocheck - TODO: re-enable typescript and properly type this\n\nlet src;\nlet srcEnd;\nlet position = 0;\n\nconst EMPTY_ARRAY = [];\n\nlet strings = EMPTY_ARRAY;\n\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\n\nlet packedValues;\n\nlet dataView;\n\nconst defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true,\n};\n\nfunction readFixedString(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\n\nclass Decoder {\n  constructor() {\n    Object.assign(this, defaultOptions);\n  }\n\n  decodeKey(key) {\n    return key;\n  }\n\n  decode(source, end? = -1) {\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView =\n        source.dataView ||\n        (source.dataView = new DataView(\n          source.buffer,\n          source.byteOffset,\n          source.byteLength,\n        ));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\n        `Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n            ? source.constructor.name\n            : typeof source}`,\n      );\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues =\n        this.sharedValues &&\n        (this.pack\n          ? new Array(this.maxPrivatePackedValues || 16).concat(\n              this.sharedValues,\n            )\n          : this.sharedValues);\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\n\nfunction checkedRead() {\n  try {\n    const result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (\n      error instanceof RangeError ||\n      error.message.startsWith(\"Unexpected end of buffer\")\n    ) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\n\nfunction read() {\n  let token = src[position++];\n  const majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n\n      default:\n        throw new Error(`Unknown token ${token}`);\n    }\n  }\n  switch (majorType) {\n    case 0: // positive int\n      return token;\n    case 1: // negative int\n      return ~token;\n    case 2: // buffer\n      return readBin(token);\n    case 3: // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(\n          position - srcStringStart,\n          (position += token) - srcStringStart,\n        );\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string =\n          token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string !== null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4: { // array\n      const array = new Array(token);\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    }\n\n    case 5: { // map\n      const object = {};\n      for (let i = 0; i < token; i++) {\n        object[safeKey(read())] = read();\n      }\n      return object;\n    }\n    default: // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(`Unknown CBOR token ${token}`);\n  }\n}\n\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === \"string\") {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  }\n  if (typeof key !== \"object\") {\n    return key.toString();\n  }\n  // protect against expensive (DoS) string conversions\n  throw new Error(`Invalid property name type ${typeof key}`);\n}\n\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  const start = position;\n  const bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      }\n        const a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n    }\n      const a = src[position++];\n      const b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) {\n        return fromCharCode(a, b);\n      }\n      const c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n  }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) {\n        return fromCharCode(a, b, c, d);\n      }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }if (length < 8) {\n      const e = src[position++];\n      const f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) {\n        return fromCharCode(a, b, c, d, e, f);\n      }\n      const g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    }\n      const e = src[position++];\n      const f = src[position++];\n      const g = src[position++];\n      const h = src[position++];\n      if (\n        (e & 0x80) > 0 ||\n        (f & 0x80) > 0 ||\n        (g & 0x80) > 0 ||\n        (h & 0x80) > 0\n      ) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) {\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n          const i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n      }if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) {\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      }\n        const i = src[position++];\n        const j = src[position++];\n        const k = src[position++];\n        const l = src[position++];\n        if (\n          (i & 0x80) > 0 ||\n          (j & 0x80) > 0 ||\n          (k & 0x80) > 0 ||\n          (l & 0x80) > 0\n        ) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          }\n            const m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n        }\n          const m = src[position++];\n          const n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          }\n          const o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\n\nfunction readBin(length) {\n  return currentDecoder.copyBuffers\n    ? // specifically use the copying slice (not the node one)\n      Uint8Array.prototype.slice.call(src, position, (position += length))\n    : src.subarray(position, (position += length));\n}\n\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n  if (src[position++] !== 0x84) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    if (src.length < position) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n  const newPackedValues = read_(); // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues\n    ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n    : newPackedValues;\n  packedValues.prefixes = read_();\n  packedValues.suffixes = read_();\n  return read_(); // read the rump\n};\npackedTable.handlesRead = true;\n\ncurrentExtensions[28] = (read_) => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  const id = referenceMap.id++;\n  const token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n\n  const refEntry = { target }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  const targetProperties = read_(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\n\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = /* @__PURE__ */ (() =>\n    Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;","import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode: string): string | undefined {\n  const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n\n  const cborLength =\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 1];\n  const cborStart = numericBytecode.length - 2 - cborLength;\n  // if the cborStart is invalid, return undefined\n  if (cborStart < 0 || cborStart > numericBytecode.length) {\n    return undefined;\n  }\n  const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData) {\n    return `ipfs://${base58Encode(cborData.ipfs)}`;\n  }\n\n  return undefined;\n}\n","import { type Hex, isHex } from \"../encoding/hex.js\";\n\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nexport function ensureBytecodePrefix(bytecode: string): Hex {\n  if (isHex(bytecode, { strict: false })) {\n    return bytecode;\n  }\n  return `0x${bytecode}`;\n}\n","import { type Abi, formatAbi, parseAbi } from \"abitype\";\nimport { getInstalledModules } from \"../../extensions/modules/__generated__/IModularCore/read/getInstalledModules.js\";\nimport { download } from \"../../storage/download.js\";\nimport { extractIPFSUri } from \"../../utils/bytecode/extractIPFS.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport type { ThirdwebContract } from \"../contract.js\";\nimport { getBytecode } from \"./get-bytecode.js\";\n\nconst ABI_RESOLUTION_CACHE = new WeakMap<ThirdwebContract<Abi>, Promise<Abi>>();\n\n/**\n * Resolves the ABI (Application Binary Interface) for a given contract.\n * If the ABI is already cached, it returns the cached value.\n * Otherwise, it tries to resolve the ABI from the contract's API.\n * If that fails, it resolves the ABI from the contract's bytecode.\n * @param contract The contract for which to resolve the ABI.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveContractAbi } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveContractAbi(myContract);\n * ```\n * @contract\n */\nexport function resolveContractAbi<abi extends Abi>(\n  contract: ThirdwebContract<abi>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<abi> {\n  if (ABI_RESOLUTION_CACHE.has(contract)) {\n    return ABI_RESOLUTION_CACHE.get(contract) as Promise<abi>;\n  }\n\n  const prom = (async () => {\n    // if the contract already HAS a user defined we always use that!\n    if (contract.abi) {\n      return contract.abi as abi;\n    }\n    // try to get it from the api\n    try {\n      return await resolveAbiFromContractApi(contract, contractApiBaseUrl);\n    } catch {\n      // if that fails, try to resolve it from the bytecode\n      return await resolveCompositeAbi(contract as ThirdwebContract);\n    }\n  })();\n  ABI_RESOLUTION_CACHE.set(contract, prom);\n  return prom as Promise<abi>;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) for a contract from the contract API.\n * @param contract The ThirdwebContract instance representing the contract.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromContractApi } from \"thirdweb/contract\"\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromContractApi(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromContractApi(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<Abi> {\n  const response = await getClientFetch(contract.client)(\n    `${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`,\n  );\n  const json = await response.json();\n  if (!json || json.error) {\n    throw new Error(\n      `Failed to resolve ABI from contract API. ${json.error || \"\"}`,\n    );\n  }\n  return json;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.\n * @param contract The ThirdwebContract instance.\n * @returns The resolved ABI as a generic type.\n * @throws Error if no IPFS URI is found in the bytecode.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromBytecode(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n): Promise<Abi> {\n  const bytecode = await getBytecode(contract);\n  if (bytecode === \"0x\") {\n    const { id, name } = contract.chain;\n    throw new Error(\n      `Failed to load contract bytecode. Make sure the contract [${\n        contract.address\n      }] exists on the chain [${name || \"Unknown Chain\"} (chain id: ${id})]`,\n    );\n  }\n  const ipfsUri = extractIPFSUri(bytecode);\n  if (!ipfsUri) {\n    // just early exit if we can't find an IPFS URI\n    return [];\n  }\n  try {\n    const res = await download({ uri: ipfsUri, client: contract.client });\n    const json = await res.json();\n    // ABI is at `json.output.abi`\n    return json.output.abi;\n  } catch {\n    // if we can't resolve the ABI from the IPFS URI, return an empty array\n    return [];\n  }\n}\n\nconst PLUGINS_ABI = {\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"bytes4\",\n          name: \"functionSelector\",\n          type: \"bytes4\",\n        },\n        {\n          internalType: \"string\",\n          name: \"functionSignature\",\n          type: \"string\",\n        },\n        {\n          internalType: \"address\",\n          name: \"pluginAddress\",\n          type: \"address\",\n        },\n      ],\n      internalType: \"struct IPluginMap.Plugin[]\",\n      name: \"registered\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst BASE_ROUTER_ABI = {\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [\n    {\n      components: [\n        {\n          components: [\n            {\n              internalType: \"string\",\n              name: \"name\",\n              type: \"string\",\n            },\n            {\n              internalType: \"string\",\n              name: \"metadataURI\",\n              type: \"string\",\n            },\n            {\n              internalType: \"address\",\n              name: \"implementation\",\n              type: \"address\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionMetadata\",\n          name: \"metadata\",\n          type: \"tuple\",\n        },\n        {\n          components: [\n            {\n              internalType: \"bytes4\",\n              name: \"functionSelector\",\n              type: \"bytes4\",\n            },\n            {\n              internalType: \"string\",\n              name: \"functionSignature\",\n              type: \"string\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionFunction[]\",\n          name: \"functions\",\n          type: \"tuple[]\",\n        },\n      ],\n      internalType: \"struct IExtension.Extension[]\",\n      name: \"allExtensions\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst DIAMOND_ABI = {\n  inputs: [],\n  name: \"facets\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"address\",\n          name: \"facetAddress\",\n          type: \"address\",\n        },\n        {\n          internalType: \"bytes4[]\",\n          name: \"functionSelectors\",\n          type: \"bytes4[]\",\n        },\n      ],\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\n/**\n * Resolves the ABI for a contract based on its bytecode.\n * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.\n * @param contract The contract for which to resolve the ABI.\n * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.\n * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.\n * @returns The resolved ABI for the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveCompositeAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveCompositeAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveCompositeAbi(\n  contract: ThirdwebContract,\n  rootAbi?: Abi,\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>,\n) {\n  const [\n    rootAbi_,\n    pluginPatternAddresses,\n    baseRouterAddresses,\n    modularExtensionAddresses,\n    diamondFacetAddresses,\n  ] = await Promise.all([\n    rootAbi ? rootAbi : resolveAbiFromBytecode(contract),\n    // check these all at the same time\n    resolvePluginPatternAddresses(contract),\n    resolveBaseRouterAddresses(contract),\n    resolveModularModuleAddresses(contract),\n    resolveDiamondFacetAddresses(contract),\n  ]);\n\n  const mergedPlugins = [\n    ...new Set([\n      ...pluginPatternAddresses,\n      ...baseRouterAddresses,\n      ...modularExtensionAddresses,\n      ...diamondFacetAddresses,\n    ]),\n  ];\n\n  // no plugins\n  if (!mergedPlugins.length) {\n    return rootAbi_;\n  }\n  // get all the abis for the plugins\n  const pluginAbis = await getAbisForPlugins({\n    contract,\n    plugins: mergedPlugins,\n    resolveSubAbi,\n  });\n\n  // join them together\n  return joinAbis({ rootAbi: rootAbi_, pluginAbis });\n}\n\nasync function resolvePluginPatternAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: PLUGINS_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.pluginAddress))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveBaseRouterAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: BASE_ROUTER_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.metadata.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveModularModuleAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const modules = await getInstalledModules({ contract });\n    // if there are no plugins, return the root ABI\n    if (!modules.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(modules.map((item) => item.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveDiamondFacetAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const facets = await readContract({ contract, method: DIAMOND_ABI });\n    // if there are no facets, return the root ABI\n    if (!facets.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return facets.map((item) => item.facetAddress);\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\ntype GetAbisForPluginsOptions = {\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>;\n  plugins: string[];\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>;\n};\n\nasync function getAbisForPlugins(\n  options: GetAbisForPluginsOptions,\n): Promise<Abi[]> {\n  return Promise.all(\n    options.plugins.map((pluginAddress) => {\n      const newContract = {\n        ...options.contract,\n        address: pluginAddress,\n      };\n      // if we have a method passed in that tells us how to resove the sub-api, use that\n      if (options.resolveSubAbi) {\n        return options.resolveSubAbi(newContract);\n      }\n      // otherwise default logic\n      return resolveAbiFromBytecode(newContract);\n    }),\n  );\n}\n\ntype JoinAbisOptions = {\n  pluginAbis: Abi[];\n  rootAbi?: Abi;\n};\n\nfunction joinAbis(options: JoinAbisOptions): Abi {\n  let mergedPlugins: Abi = options.pluginAbis\n    .flat()\n    .filter((item) => item.type !== \"constructor\");\n\n  if (options.rootAbi) {\n    mergedPlugins = [...(options.rootAbi || []), ...mergedPlugins].filter(\n      Boolean,\n    );\n  }\n\n  // unique by formatting every abi and then throwing them in a set\n  // TODO: this may not be super efficient...\n  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];\n  // finally parse it back out\n  return parseAbi(humanReadableAbi);\n}\n","import type { Abi } from '../abi.js'\nimport type { Error, Filter } from '../types.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * type Result = ParseAbi<\n *   // ^? type Result = readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   [\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'event Transfer(address indexed from, address indexed to, uint256 amount)',\n *   ]\n * >\n */\nexport type ParseAbi<signatures extends readonly string[]> =\n  string[] extends signatures\n    ? Abi // If `T` was not able to be inferred (e.g. just `string[]`), return `Abi`\n    : signatures extends readonly string[]\n      ? signatures extends Signatures<signatures> // Validate signatures\n        ? ParseStructs<signatures> extends infer sructs\n          ? {\n              [key in keyof signatures]: signatures[key] extends string\n                ? ParseSignature<signatures[key], sructs>\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends infer result\n              ? result extends readonly []\n                ? never\n                : result\n              : never\n            : never\n          : never\n        : never\n      : never\n\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-Readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * const abi = parseAbi([\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   'function balanceOf(address owner) view returns (uint256)',\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\n * ])\n */\nexport function parseAbi<const signatures extends readonly string[]>(\n  signatures: signatures['length'] extends 0\n    ? Error<'At least one signature required'>\n    : Signatures<signatures> extends signatures\n      ? signatures\n      : Signatures<signatures>,\n): ParseAbi<signatures> {\n  const structs = parseStructs(signatures as readonly string[])\n  const abi = []\n  const length = signatures.length as number\n  for (let i = 0; i < length; i++) {\n    const signature = (signatures as readonly string[])[i]!\n    if (isStructSignature(signature)) continue\n    abi.push(parseSignature(signature, structs))\n  }\n  return abi as unknown as ParseAbi<signatures>\n}\n","import type { Abi } from \"abitype\";\nimport { type Hex, decodeErrorResult } from \"viem\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { isHex } from \"../utils/encoding/hex.js\";\nimport { stringify } from \"../utils/json.js\";\n\n/**\n * @internal\n */\nexport async function extractError<abi extends Abi>(args: {\n  error: unknown;\n  contract?: ThirdwebContract<abi>;\n}) {\n  const { error, contract } = args;\n  if (typeof error === \"object\") {\n    // try to parse RPC error\n    const errorObj = error as {\n      message?: string;\n      code?: number;\n      data?: Hex;\n    };\n    if (errorObj.data) {\n      if (errorObj.data !== \"0x\" && isHex(errorObj.data)) {\n        let abi = contract?.abi;\n        if (contract && !abi) {\n          abi = await resolveContractAbi(contract).catch(() => undefined);\n        }\n        const parsedError = decodeErrorResult({\n          data: errorObj.data,\n          abi,\n        });\n        return new TransactionError(\n          `${parsedError.errorName}${\n            parsedError.args ? ` - ${parsedError.args}` : \"\"\n          }`,\n          contract,\n        );\n      }\n      return new TransactionError(\n        `Execution Reverted: ${stringify(errorObj)}`,\n        contract,\n      );\n    }\n  }\n  return error;\n}\n\nexport const __DEV__ = process.env.NODE_ENV !== \"production\";\n\nclass TransactionError<abi extends Abi> extends Error {\n  public contractAddress: string | undefined;\n  public chainId: number | undefined;\n\n  constructor(reason: string, contract?: ThirdwebContract<abi>) {\n    let message = reason;\n    if (__DEV__ && contract) {\n      // show more infor in dev\n      message = [\n        reason,\n        \"\",\n        `contract: ${contract.address}`,\n        `chainId: ${contract.chain?.id}`,\n      ].join(\"\\n\");\n    }\n    super(message);\n    this.name = \"TransactionError\";\n    this.contractAddress = contract?.address;\n    this.chainId = contract?.chain?.id;\n    this.message = message;\n  }\n}\n","import { formatTransactionRequest } from \"viem\";\nimport { roundUpGas } from \"../../gas/op-gas-fee-reducer.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError as parseEstimationError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nexport type EstimateGasOptions = Prettify<\n  {\n    /**\n     * The prepared transaction to estimate the gas for.\n     */\n    // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n    // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n    transaction: PreparedTransaction<any>;\n  } & (\n    | {\n        /**\n         * The account the transaction would be sent from.\n         */\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        /**\n         * The address the transaction would be sent from.\n         */\n        from?: string;\n      }\n  )\n>;\n\nexport type EstimateGasResult = bigint;\n\nconst cache = new WeakMap<\n  PreparedTransaction & { from: string | undefined },\n  Promise<EstimateGasResult>\n>();\n\n/**\n * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.\n * @param options - The options for estimating gas.\n * @returns A promise that resolves to the estimated gas as a bigint.\n * @transaction\n * @example\n * ```ts\n * import { estimateGas } from \"thirdweb\";\n * const gas = await estimateGas({\n *  transaction,\n * });\n * ```\n */\nexport async function estimateGas(\n  options: EstimateGasOptions,\n): Promise<EstimateGasResult> {\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = options.from ?? options.account?.address ?? undefined;\n  const txWithFrom = { ...options.transaction, from };\n  if (cache.has(txWithFrom)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return cache.get(txWithFrom)!;\n  }\n  const { account } = options;\n  const promise = (async () => {\n    const predefinedGas = await resolvePromisedValue(options.transaction.gas);\n    // if we have a predefined gas value in the TX -> always use that\n    if (predefinedGas !== undefined) {\n      return predefinedGas;\n    }\n\n    // if the wallet itself overrides the estimateGas function, use that\n    if (account?.estimateGas) {\n      try {\n        let gas = await account.estimateGas(options.transaction);\n        if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n          gas = roundUpGas(gas);\n        }\n        return gas;\n      } catch (error) {\n        throw await parseEstimationError({\n          error,\n          contract: options.transaction.__contract,\n        });\n      }\n    }\n\n    // load up encode function if we need it\n    const { encode } = await import(\"./encode.js\");\n    const [encodedData, toAddress, value] = await Promise.all([\n      encode(options.transaction),\n      resolvePromisedValue(options.transaction.to),\n      resolvePromisedValue(options.transaction.value),\n    ]);\n\n    // load up the rpc client and the estimateGas function if we need it\n    const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([\n      import(\"../../rpc/rpc.js\"),\n      import(\"../../rpc/actions/eth_estimateGas.js\"),\n    ]);\n\n    const rpcRequest = getRpcClient(options.transaction);\n    try {\n      let gas = await eth_estimateGas(\n        rpcRequest,\n        formatTransactionRequest({\n          to: toAddress,\n          data: encodedData,\n          from,\n          value,\n        }),\n      );\n      if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n        gas = roundUpGas(gas);\n      }\n      return gas;\n    } catch (error) {\n      throw await parseEstimationError({\n        error,\n        contract: options.transaction.__contract,\n      });\n    }\n  })();\n  cache.set(txWithFrom, promise);\n  return promise;\n}\n","import type { TransactionSerializable } from \"viem\";\nimport { getGasOverridesForTransaction } from \"../../gas/fee-data.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport { encode } from \"./encode.js\";\nimport { estimateGas } from \"./estimate-gas.js\";\n\nexport type ToSerializableTransactionOptions = {\n  /**\n   * The transaction to convert to a serializable transaction.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  transaction: PreparedTransaction<any>;\n  /**\n   * The from address to use for gas estimation.\n   */\n  from?: string;\n};\n\n/**\n * Converts a prepared transaction to a transaction with populated options.\n * @param options - The transaction and additional options for conversion\n * @returns A serializable transaction for inspection or submission to an account.\n *\n * @note For easier transaction sending, {@see sendTransaction}\n * @example\n * ```ts\n * import { prepareTransaction, toSerializableTransaction } from \"thirdweb\";\n *\n * const transaction = await prepareTransaction({\n *   transaction: {\n *     to: \"0x...\",\n *     value: 100,\n *   },\n * });\n * const finalTx = await toSerializableTransaction({\n *   transaction,\n * });\n *\n * account.sendTransaction(finalTx);\n * ```\n * @transaction\n */\nexport async function toSerializableTransaction(\n  options: ToSerializableTransactionOptions,\n) {\n  const rpcRequest = getRpcClient(options.transaction);\n  const chainId = options.transaction.chain.id;\n  const from = options.from;\n  let [data, nonce, gas, feeData, to, accessList, value] = await Promise.all([\n    encode(options.transaction),\n    (async () => {\n      // if the user has specified a nonce, use that\n      const resolvedNonce = await resolvePromisedValue(\n        options.transaction.nonce,\n      );\n      if (resolvedNonce !== undefined) {\n        return resolvedNonce;\n      }\n\n      return from // otherwise get the next nonce (import the method to do so)\n        ? await import(\"../../rpc/actions/eth_getTransactionCount.js\").then(\n            ({ eth_getTransactionCount }) =>\n              eth_getTransactionCount(rpcRequest, {\n                address: from,\n                blockTag: \"pending\",\n              }),\n          )\n        : undefined;\n    })(),\n    // takes the same options as the sendTransaction function thankfully!\n    estimateGas(options),\n    getGasOverridesForTransaction(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n  ]);\n\n  const extraGas = await resolvePromisedValue(options.transaction.extraGas);\n  if (extraGas) {\n    gas += extraGas;\n  }\n\n  return {\n    to,\n    chainId,\n    data,\n    gas,\n    nonce,\n    accessList,\n    value,\n    ...feeData,\n  } satisfies TransactionSerializable;\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Choice: a ? b : c\nexport const Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nexport const Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = SHA256_IV[0] | 0;\n  B = SHA256_IV[1] | 0;\n  C = SHA256_IV[2] | 0;\n  D = SHA256_IV[3] | 0;\n  E = SHA256_IV[4] | 0;\n  F = SHA256_IV[5] | 0;\n  G = SHA256_IV[6] | 0;\n  H = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","import { maxUint16 } from '../../constants/number.js'\n\nexport const gasPerPubdataDefault = 50000n\nexport const maxBytecodeSize = maxUint16 * 32n\n","import { BaseError } from '../../errors/base.js'\n\nexport type BytecodeLengthExceedsMaxSizeErrorType =\n  BytecodeLengthExceedsMaxSizeError & {\n    name: 'BytecodeLengthExceedsMaxSizeError'\n  }\n\nexport class BytecodeLengthExceedsMaxSizeError extends BaseError {\n  constructor({\n    givenLength,\n    maxBytecodeSize,\n  }: { givenLength: number; maxBytecodeSize: bigint }) {\n    super(\n      `Bytecode cannot be longer than ${maxBytecodeSize} bytes. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthExceedsMaxSizeError' },\n    )\n  }\n}\n\nexport type BytecodeLengthInWordsMustBeOddErrorType =\n  BytecodeLengthInWordsMustBeOddError & {\n    name: 'BytecodeLengthInWordsMustBeOddError'\n  }\n\nexport class BytecodeLengthInWordsMustBeOddError extends BaseError {\n  constructor({ givenLengthInWords }: { givenLengthInWords: number }) {\n    super(\n      `Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`,\n      { name: 'BytecodeLengthInWordsMustBeOddError' },\n    )\n  }\n}\n\nexport type BytecodeLengthMustBeDivisibleBy32ErrorType =\n  BytecodeLengthMustBeDivisibleBy32Error & {\n    name: 'BytecodeLengthMustBeDivisibleBy32Error'\n  }\n\nexport class BytecodeLengthMustBeDivisibleBy32Error extends BaseError {\n  constructor({ givenLength }: { givenLength: number }) {\n    super(\n      `The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthMustBeDivisibleBy32Error' },\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { pad } from '../../utils/data/pad.js'\nimport { type ToBytesErrorType, toBytes } from '../../utils/encoding/toBytes.js'\nimport { type Sha256ErrorType, sha256 } from '../../utils/hash/sha256.js'\nimport { maxBytecodeSize } from '../constants/number.js'\nimport {\n  BytecodeLengthExceedsMaxSizeError,\n  type BytecodeLengthExceedsMaxSizeErrorType,\n  BytecodeLengthInWordsMustBeOddError,\n  type BytecodeLengthInWordsMustBeOddErrorType,\n  BytecodeLengthMustBeDivisibleBy32Error,\n  type BytecodeLengthMustBeDivisibleBy32ErrorType,\n} from '../errors/bytecode.js'\n\nexport type HashBytecodeErrorType =\n  | BytecodeLengthExceedsMaxSizeErrorType\n  | BytecodeLengthInWordsMustBeOddErrorType\n  | BytecodeLengthMustBeDivisibleBy32ErrorType\n  | Sha256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashBytecode(bytecode: Hex): Uint8Array {\n  const bytecodeBytes = toBytes(bytecode)\n  if (bytecodeBytes.length % 32 !== 0)\n    throw new BytecodeLengthMustBeDivisibleBy32Error({\n      givenLength: bytecodeBytes.length,\n    })\n\n  if (bytecodeBytes.length > maxBytecodeSize)\n    throw new BytecodeLengthExceedsMaxSizeError({\n      givenLength: bytecodeBytes.length,\n      maxBytecodeSize,\n    })\n\n  const hashStr = sha256(bytecodeBytes)\n  const hash = toBytes(hashStr)\n\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords,\n    })\n  }\n\n  const bytecodeLength = toBytes(bytecodeLengthInWords)\n\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 })\n\n  const codeHashVersion = new Uint8Array([1, 0])\n  hash.set(codeHashVersion, 0)\n  hash.set(bytecodeLengthPadded, 2)\n\n  return hash\n}\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Sha256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<to>\n  return toHex(bytes) as Sha256Hash<to>\n}\n","import type { TransactionSerializable } from \"viem\";\nimport { hashBytecode } from \"viem/zksync\";\nimport type { Address } from \"../../../utils/address.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  EIP712SerializedTransaction,\n  EIP712TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP712TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP712SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n    factoryDeps,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n","import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\nexport type SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit) * 2n; // doubling for fast inclusion;\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n","import type { EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\n/**\n * Sends a raw transaction to the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param signedTransaction - The signed transaction in hex format.\n * @returns A promise that resolves to the transaction hash.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_sendRawTransaction } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionHash = await eth_sendRawTransaction(rpcRequest, \"0x...\");\n * ```\n */\nexport async function eth_sendRawTransaction(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  signedTransaction: Hex,\n) {\n  return await request({\n    method: \"eth_sendRawTransaction\",\n    params: [signedTransaction],\n  });\n}\n","import type { Abi, AbiFunction, Address } from \"abitype\";\nimport type { AccessList, Hex } from \"viem\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport type { PreparedMethod } from \"../utils/abi/prepare-method.js\";\nimport type { PromisedObject } from \"../utils/promise/resolve-promised-value.js\";\n\nexport type StaticPrepareTransactionOptions = {\n  accessList?: AccessList | undefined;\n  to?: Address | undefined;\n  data?: Hex | undefined;\n  value?: bigint | undefined;\n  gas?: bigint | undefined;\n  gasPrice?: bigint | undefined;\n  maxFeePerGas?: bigint | undefined;\n  maxPriorityFeePerGas?: bigint | undefined;\n  maxFeePerBlobGas?: bigint | undefined;\n  nonce?: number | undefined;\n  extraGas?: bigint | undefined;\n  // zksync specific\n  eip712?: EIP712TransactionOptions | undefined;\n  // tw specific\n  chain: Chain;\n  client: ThirdwebClient;\n  // extras\n  extraCallData?: Hex;\n  erc20Value?: {\n    amountWei: bigint;\n    tokenAddress: Address;\n  };\n};\n\nexport type EIP712TransactionOptions = {\n  // constant or user input\n  gasPerPubdata?: bigint | undefined;\n  // optional signature, generated\n  customSignature?: Hex | undefined;\n  // optional, used to deploy contracts with the transaction\n  factoryDeps?: Hex[] | undefined;\n  // optional, paymaster contract address to invoke\n  paymaster?: Address | undefined;\n  // optional, paymaster contract input\n  paymasterInput?: Hex | undefined;\n};\n\nexport type EIP712SerializedTransaction = {\n  txType: bigint;\n  from: bigint;\n  to: bigint;\n  gasLimit: bigint;\n  gasPerPubdataByteLimit: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  nonce: bigint;\n  value: bigint;\n  data: Hex;\n  factoryDeps: Hex[];\n  paymaster: bigint;\n  paymasterInput: Hex;\n};\n\nexport type PrepareTransactionOptions = {\n  chain: Chain;\n  client: ThirdwebClient;\n} & PromisedObject<Omit<StaticPrepareTransactionOptions, \"chain\" | \"client\">>;\n\ntype Additional<\n  abi extends Abi = [],\n  abiFn extends AbiFunction = AbiFunction,\n> = {\n  preparedMethod: () => Promise<PreparedMethod<abiFn>>;\n  contract: ThirdwebContract<abi>;\n};\n\nexport type PreparedTransaction<\n  abi extends Abi = [],\n  abiFn extends AbiFunction = AbiFunction,\n  options extends PrepareTransactionOptions = PrepareTransactionOptions,\n> = Readonly<options> & {\n  __preparedMethod?: () => Promise<PreparedMethod<abiFn>>;\n  __contract?: ThirdwebContract<abi>;\n};\n\n/**\n * Prepares a transaction with the given options.\n * @param options - The options for preparing the transaction.\n * @param info - Additional information about the ABI function.\n * @returns The prepared transaction.\n * @transaction\n * @example\n * ```ts\n * import { prepareTransaction, toWei } from \"thirdweb\";\n * import { ethereum } from \"thirdweb/chains\";\n * const transaction = prepareTransaction({\n *  to: \"0x1234567890123456789012345678901234567890\",\n *  chain: ethereum,\n *  client: thirdwebClient,\n *  value: toWei(\"1.0\"),\n *  gasPrice: 30n\n * });\n * ```\n */\nexport function prepareTransaction<\n  const abi extends Abi = [],\n  const abiFn extends AbiFunction = AbiFunction,\n>(options: PrepareTransactionOptions, info?: Additional<abi, abiFn>) {\n  if (info) {\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    (options as any).__preparedMethod = info.preparedMethod;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    (options as any).__contract = info.contract;\n  }\n  return options as PreparedTransaction<abi, abiFn>;\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { type TransactionRequest, decodeAbiParameters } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\n\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * You can use raw read calls or read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) to read from a contract.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Using a contract read extension\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n * import { getOwnedNFTs } form \"thirdweb/extensions/erc721\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract(getOwnedNFTs, { contract, owner: address });\n * ```\n *\n * ### Using a raw contract call\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\"}),\n *   params: [1n],\n * });\n * ```\n *\n * ### Using `resolveMethod`\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    to: contract.address,\n    from: options.from,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          code: override.code,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n","import type { AbiFunction } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiFunction(item: unknown): item is AbiFunction {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"function\"\n  );\n}\n","import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from \"abitype\";\nimport { concat, slice } from \"viem/utils\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport {\n  type Hex,\n  boolToHex,\n  numberToHex,\n  padHex,\n  stringToHex,\n} from \"../encoding/hex.js\";\n\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"viem\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): Hex {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\n\n//UTILS\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex };\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] };\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>;\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams;\n  values: AbiParametersToPrimitiveTypes<TParams>;\n}) {\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({ param: params[i]!, value: values[i] }));\n  }\n  return preparedParams;\n}\n\n/**\n * @internal Export for unit test\n */\nexport function prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam;\n  value: AbiParameterToPrimitiveType<TParam>;\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value as unknown as Hex);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value as unknown as boolean);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value as unknown as number, { signed });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value as unknown as Hex, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value as unknown as string);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = [];\n  const dynamicParams: Hex[] = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams]);\n}\n\n/////////////////////////////////////////////////////////////////\n\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value: Hex): PreparedParam {\n  // We allow empty strings for deployment transactions where there is no to address\n  if ((value as string) !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(`Invalid address: ${value}`);\n  }\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) };\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null;\n    param: TParam;\n  },\n): PreparedParam {\n  const dynamic = length === null;\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n\n  let dynamicChild = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length_, data]) : length_,\n      };\n    }\n    if (dynamicChild) {\n      return { dynamic: true, encoded: data };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  };\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts: Hex[] = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: \"right\",\n      }),\n    );\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(byteSize(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  };\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i]!;\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: (value as any)[index!] as readonly unknown[],\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n","import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n","import type { Hex } from \"./is-hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace(\"0x\", \"\"),\n    \"\",\n  )}`;\n}\n","/**\n * Resolves a possibly asynchronous value.\n * If the value is a function that returns a promise, it will be awaited and the resolved value will be returned.\n * Otherwise, the value itself will be returned.\n *\n * @param value - The value to resolve.\n * @returns A promise that resolves to the resolved value.\n * @internal\n */\nexport async function resolvePromisedValue<V>(\n  value: V,\n): Promise<V extends () => Promise<infer R> ? R : V> {\n  return typeof value === \"function\" ? await value() : value;\n}\n\nexport type PromisedValue<T> = T | (() => Promise<T>);\n\nexport type PromisedObject<T> = {\n  [K in keyof T]: PromisedValue<T[K]>;\n};\n","/**\n * Converts a given number of units to a string representation with a specified number of decimal places.\n * @param units - The number of units to convert.\n * @param decimals - The number of decimal places to include in the string representation.\n * @returns The string representation of the converted units.\n * @example\n * ```ts\n * import { toTokens } from \"thirdweb/utils\";\n * toTokens(1000000000000000000n, 18)\n * // '1'\n * ```\n * @utils\n */\nexport function toTokens(units: bigint, decimals: number): string {\n  // Convert to string once and handle negativity.\n  const stringValue = units.toString();\n  const prefix = stringValue[0] === \"-\" ? \"-\" : \"\";\n  // Abusing that string \"-\" is truthy\n  const absStringValue = prefix ? stringValue.slice(1) : stringValue;\n\n  // Ensure we have enough digits for the fractional part.\n  const paddedValue = absStringValue.padStart(decimals + 1, \"0\");\n  const splitIndex = paddedValue.length - decimals;\n\n  // Extract integer and fraction parts directly.\n  const integerPart = paddedValue.slice(0, splitIndex) || \"0\";\n  let fractionPart = paddedValue.slice(splitIndex);\n\n  // Manually trim trailing zeros from the fraction part.\n  for (let i = fractionPart.length - 1; i >= 0; i--) {\n    if (fractionPart[i] !== \"0\") {\n      fractionPart = fractionPart.slice(0, i + 1);\n      break;\n    }\n    // check if the next digit is a zero also\n    // If all zeros, make fraction part empty\n    if (i === 0) {\n      fractionPart = \"\";\n    }\n  }\n\n  // Construct and return the formatted string.\n  return `${prefix}${integerPart}${fractionPart ? `.${fractionPart}` : \"\"}`;\n}\n\n/**\n * Converts a value from wei to ether.\n * @param wei The value in wei to be converted.\n * @returns The converted value in ether.\n * @example\n * ```ts\n * import { toEther } from \"thirdweb/utils\";\n * toEther(1000000000000000000n)\n * // '1'\n * ```\n * @utils\n */\nexport function toEther(wei: bigint) {\n  return toTokens(wei, 18);\n}\n\n/**\n * Converts a string representation of a number with decimal places to a BigInt representation.\n * @param tokens - The string representation of the number, including the integer and fraction parts.\n * @param decimals - The number of decimal places to include in the BigInt representation.\n * @returns The BigInt representation of the number.\n * @example\n * ```ts\n * import { toUnits } from \"thirdweb/utils\";\n * toUnits('1', 18)\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toUnits(tokens: string, decimals: number): bigint {\n  let [integerPart, fractionPart = \"\"] = tokens.split(\".\") as [string, string];\n  const prefix = integerPart.startsWith(\"-\") ? \"-\" : \"\";\n  if (prefix) {\n    integerPart = integerPart.slice(1);\n  }\n\n  fractionPart = fractionPart.padEnd(decimals, \"0\"); // Ensure fraction part is at least 'decimals' long.\n\n  if (decimals === 0) {\n    // Check if there's any fraction part that would necessitate rounding up the integer part.\n    if (fractionPart[0] && Number.parseInt(fractionPart[0]) >= 5) {\n      integerPart = (BigInt(integerPart) + 1n).toString();\n    }\n    fractionPart = \"\"; // No fraction part is needed when decimals === 0.\n  } else {\n    // When decimals > 0, handle potential rounding based on the digit right after the specified decimal places.\n    if (fractionPart.length > decimals) {\n      const roundingDigit = fractionPart[decimals];\n      if (roundingDigit && Number.parseInt(roundingDigit, 10) >= 5) {\n        // If rounding is needed, add 1 to the last included digit of the fraction part.\n        const roundedFraction =\n          BigInt(fractionPart.substring(0, decimals)) + 1n;\n        fractionPart = roundedFraction.toString().padStart(decimals, \"0\");\n\n        if (fractionPart.length > decimals) {\n          // If rounding the fraction results in a length increase (e.g., .999 -> 1.000), increment the integer part.\n          integerPart = (BigInt(integerPart) + 1n).toString();\n          // Adjust the fraction part if it's longer than the specified decimals due to rounding up.\n          fractionPart = fractionPart.substring(fractionPart.length - decimals);\n        }\n      } else {\n        // If no rounding is necessary, just truncate the fraction part to the specified number of decimals.\n        fractionPart = fractionPart.substring(0, decimals);\n      }\n    }\n    // If the fraction part is shorter than the specified decimals, it's already handled by padEnd() above.\n  }\n\n  // Combine the integer and fraction parts into the final BigInt representation.\n  return BigInt(`${prefix}${integerPart}${fractionPart}`);\n}\n\n/**\n * Converts the specified number of tokens to Wei.\n * @param tokens The number of tokens to convert.\n * @returns The converted value in Wei.\n * @example\n * ```ts\n * import { toWei } from \"thirdweb/utils\";\n * toWei('1')\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toWei(tokens: string) {\n  return toUnits(tokens, 18);\n}\n\n/**\n * Converts the specified number from gwei to wei.\n * @param gwei The number of gwei to convert.\n * @returns The converted value in wei.\n * @example\n * ```ts\n * import { fromGwei } from \"thirdweb/utils\";\n * fromGwei('1')\n * // 1000000000n\n * ```\n * @utils\n */\nexport function fromGwei(gwei: string) {\n  return toUnits(gwei, 9);\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"allowance\" function.\n */\nexport type AllowanceParams = {\n  owner: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"owner\" }>;\n  spender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"spender\" }>;\n};\n\nexport const FN_SELECTOR = \"0xdd62ed3e\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"owner\",\n  },\n  {\n    type: \"address\",\n    name: \"spender\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `allowance` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `allowance` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isAllowanceSupported } from \"thirdweb/extensions/erc20\";\n * const supported = isAllowanceSupported([\"0x...\"]);\n * ```\n */\nexport function isAllowanceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"allowance\" function.\n * @param options - The options for the allowance function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowanceParams } from \"thirdweb/extensions/erc20\";\n * const result = encodeAllowanceParams({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowanceParams(options: AllowanceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.owner, options.spender]);\n}\n\n/**\n * Encodes the \"allowance\" function into a Hex string with its parameters.\n * @param options - The options for the allowance function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowance } from \"thirdweb/extensions/erc20\";\n * const result = encodeAllowance({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowance(options: AllowanceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeAllowanceParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the allowance function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeAllowanceResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeAllowanceResultResult(\"...\");\n * ```\n */\nexport function decodeAllowanceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"allowance\" function on the contract.\n * @param options - The options for the allowance function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { allowance } from \"thirdweb/extensions/erc20\";\n *\n * const result = await allowance({\n *  contract,\n *  owner: ...,\n *  spender: ...,\n * });\n *\n * ```\n */\nexport async function allowance(\n  options: BaseTransactionOptions<AllowanceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.owner, options.spender],\n  });\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport type { TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport {\n  type PrepareTransactionOptions,\n  prepareTransaction,\n} from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type PrepareContractCallOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    contract: ThirdwebContract<TAbi>;\n    method: TMethod | TPreparedMethod;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.\n * @param options - The options for preparing the contract call.\n * @returns A promise that resolves to the prepared transaction.\n * @transaction\n * @example\n *\n * ### Usage with a human-readable method signature:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with explicit gas price and/or value:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n *  maxFeePerGas: 30n,\n *  maxPriorityFeePerGas: 1n,\n *  value: toWei(\"0.01\"),\n * });\n * ```\n *\n * ### Usage with a JSON ABI function object:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: {\n *    name: \"transfer\",\n *    type: \"function\",\n *    inputs: [\n *      { name: \"to\", type: \"address\" },\n *      { name: \"value\", type: \"uint256\" },\n *    ],\n *    outputs: [],\n *    stateMutability: \"payable\"\n *   },\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with the ABI defined on the contract:\n *\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *  ..., // chain, address, client\n *  abi: [...] // ABI with a \"transfer\" method\n * });\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"transfer\", // <- this gets inferred from the contract\n *  params: [to, value],\n * });\n * ```\n *\n * ### Passing extra call data to the transaction\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *   ..., // chain, address, client\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [...],\n *   // The extra call data MUST be encoded to hex before passing\n *   extraCallData: \"0x.......\"\n * });\n * ```\n */\nexport function prepareContractCall<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(options: PrepareContractCallOptions<TAbi, TMethod, TPreparedMethod>) {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params, ...rest } = options;\n\n  const preparedMethodPromise = () =>\n    (async () => {\n      if (Array.isArray(method)) {\n        return method as PreparedMethod_;\n      }\n      if (isAbiFunction(method)) {\n        return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n      }\n\n      if (typeof method === \"function\") {\n        return prepareMethod(\n          // @ts-expect-error - method *is* function in this case\n          (await method(contract)) as ParsedMethod_,\n        ) as PreparedMethod_;\n      }\n      // if the method starts with the string `function ` we always will want to try to parse it\n      if (typeof method === \"string\" && method.startsWith(\"function \")) {\n        // @ts-expect-error - method *is* string in this case\n        const abiItem = parseAbiItem(method);\n        if (abiItem.type === \"function\") {\n          return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n        }\n        throw new Error(`\"method\" passed is not of type \"function\"`);\n      }\n      // check if we have a \"abi\" on the contract\n      if (contract.abi && contract.abi?.length > 0) {\n        // extract the abiFunction from it\n        const abiFunction = contract.abi?.find(\n          (item) => item.type === \"function\" && item.name === method,\n        );\n        // if we were able to find it -> return it\n        if (abiFunction) {\n          return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n        }\n      }\n      throw new Error(`Could not resolve method \"${method}\".`);\n    })();\n\n  return prepareTransaction(\n    {\n      ...rest,\n      // these always inferred from the contract\n      to: contract.address,\n      chain: contract.chain,\n      client: contract.client,\n      data: async () => {\n        let preparedM: PreparedMethod_;\n        if (Array.isArray(method)) {\n          preparedM = method as PreparedMethod_;\n        } else {\n          preparedM = await preparedMethodPromise();\n        }\n\n        if (preparedM[1].length === 0) {\n          // just return the fn sig directly -> no params\n          return preparedM[0];\n        }\n\n        // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n        // we can do this because we know the specific formats of the values\n        return (preparedM[0] +\n          encodeAbiParameters(\n            preparedM[1],\n            // @ts-expect-error - TODO: fix this type issue\n            await resolvePromisedValue(params ?? []),\n          ).slice(2)) as `${(typeof preparedM)[0]}${string}`;\n      },\n    },\n    {\n      preparedMethod: preparedMethodPromise,\n      contract: contract,\n    },\n  );\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"approve\" function.\n */\nexport type ApproveParams = WithOverrides<{\n  spender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"spender\" }>;\n  value: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"value\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x095ea7b3\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"spender\",\n  },\n  {\n    type: \"uint256\",\n    name: \"value\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bool\",\n  },\n] as const;\n\n/**\n * Checks if the `approve` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `approve` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isApproveSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = isApproveSupported([\"0x...\"]);\n * ```\n */\nexport function isApproveSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"approve\" function.\n * @param options - The options for the approve function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeApproveParams } from \"thirdweb/extensions/erc20\";\n * const result = encodeApproveParams({\n *  spender: ...,\n *  value: ...,\n * });\n * ```\n */\nexport function encodeApproveParams(options: ApproveParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.spender, options.value]);\n}\n\n/**\n * Encodes the \"approve\" function into a Hex string with its parameters.\n * @param options - The options for the approve function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeApprove } from \"thirdweb/extensions/erc20\";\n * const result = encodeApprove({\n *  spender: ...,\n *  value: ...,\n * });\n * ```\n */\nexport function encodeApprove(options: ApproveParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeApproveParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"approve\" function on the contract.\n * @param options - The options for the \"approve\" function.\n * @returns A prepared transaction object.\n * @extension ERC20\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { approve } from \"thirdweb/extensions/erc20\";\n *\n * const transaction = approve({\n *  contract,\n *  spender: ...,\n *  value: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function approve(\n  options: BaseTransactionOptions<\n    | ApproveParams\n    | {\n        asyncParams: () => Promise<ApproveParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.spender, resolvedOptions.value] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n  });\n}\n","import type { Address } from \"abitype\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport type { Prettify } from \"../../../utils/type-utils.js\";\nimport { toUnits } from \"../../../utils/units.js\";\nimport { approve as generatedApprove } from \"../__generated__/IERC20/write/approve.js\";\n\n/**\n * Represents the parameters for the `approve` function.\n * @extension ERC20\n */\nexport type ApproveParams = Prettify<\n  { spender: Address } & (\n    | {\n        amount: number | string;\n      }\n    | {\n        amountWei: bigint;\n      }\n  )\n>;\n\n/**\n * Approves the spending of tokens by a specific address.\n * @param options - The transaction options.\n * @returns A prepared transaction object.\n * @extension ERC20\n * @example\n * ```ts\n * import { approve } from \"thirdweb/extensions/erc20\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const transaction = await approve({\n *  contract,\n *  spender: \"0x...\",\n *  amount: 100,\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function approve(options: BaseTransactionOptions<ApproveParams>) {\n  return generatedApprove({\n    contract: options.contract,\n    asyncParams: async () => {\n      let amount: bigint;\n      if (\"amount\" in options) {\n        // if we need to parse the amount from ether to gwei then we pull in the decimals extension\n        const { decimals } = await import(\"../read/decimals.js\");\n        // if this fails we fall back to `18` decimals\n        const d = await decimals(options).catch(() => 18);\n        // turn ether into gwei\n        amount = toUnits(options.amount.toString(), d);\n      } else {\n        amount = options.amountWei;\n      }\n      return {\n        spender: options.spender,\n        value: amount,\n        overrides: {\n          erc20Value: {\n            amountWei: amount,\n            tokenAddress: options.contract.address,\n          },\n        },\n      } as const;\n    },\n  });\n}\n","type OnceFn<T> = () => Promise<T>;\n\nexport function once<const T>(fn: OnceFn<T>): OnceFn<T> {\n  let result: Promise<T>;\n  return () => {\n    if (!result) {\n      result = fn();\n    }\n    return result;\n  };\n}\n","import type { TypedData } from \"abitype\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { type Hex, hexToNumber, isHex } from \"../../encoding/hex.js\";\n\ntype UnknownDomain = unknown & { chainId?: unknown }; // TODO: create our own typed data types so this is cleaner\ntype HexDomain = unknown & { chainId: Hex }; // TODO: create our own typed data types so this is cleaner\n\n/**\n * @internal\n */\nexport function parseTypedData<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>(\n  typedData: TypedDataDefinition<typedData, primaryType>,\n): TypedDataDefinition<typedData, primaryType> {\n  const domain = typedData.domain as UnknownDomain;\n  if (domain?.chainId !== undefined && isHex(domain.chainId)) {\n    typedData.domain = {\n      ...(typedData.domain as HexDomain),\n      chainId: hexToNumber((typedData.domain as unknown as HexDomain).chainId),\n    } as unknown as TypedDataDefinition<typedData, primaryType>[\"domain\"];\n  }\n  return typedData;\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\n\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = abi.find(\n    (x) =>\n      x.type === 'event' &&\n      signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: nonIndexedInputs,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\nimport { getAbiItem } from './getAbiItem.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = getAbiItem({\n          abi: abi as Abi,\n          name: log.topics[0] as string,\n        }) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (!value) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (!value) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import { BaseError } from './base.js'\n\nexport type FilterTypeNotSupportedErrorType = FilterTypeNotSupportedError & {\n  name: 'FilterTypeNotSupportedError'\n}\nexport class FilterTypeNotSupportedError extends BaseError {\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`, {\n      name: 'FilterTypeNotSupportedError',\n    })\n  }\n}\n","import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  ExtractAbiEvents,\n} from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeEventTopics'\n\nexport type EncodeEventTopicsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  ///\n  hasEvents = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiEvents<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>\n  >,\n  allErrorNames = ContractEventName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { eventName?: eventName | allErrorNames | undefined }\n      : { eventName: eventName | allErrorNames }\n    : { eventName?: eventName | allErrorNames | undefined }\n> &\n  (hasEvents extends true ? unknown : never)\n\nexport type EncodeEventTopicsReturnType = [Hex, ...(Hex | Hex[] | null)[]]\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n>(\n  parameters: EncodeEventTopicsParameters<abi, eventName>,\n): EncodeEventTopicsReturnType {\n  const { abi, eventName, args } = parameters as EncodeEventTopicsParameters\n\n  let abiItem = abi[0]\n  if (eventName) {\n    const item = getAbiItem({ abi, name: eventName })\n    if (!item) throw new AbiEventNotFoundError(eventName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toEventSelector(definition as EventDefinition)\n\n  let topics: (Hex | Hex[] | null)[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? indexedInputs?.map((x: any) => (args as any)[x.name]) ?? []\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) => {\n          if (Array.isArray(args_[i]))\n            return args_[i].map((_: any, j: number) =>\n              encodeArg({ param, value: args_[i][j] }),\n            )\n          return args_[i] ? encodeArg({ param, value: args_[i] }) : null\n        }) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n","import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { type Hex, encodeEventTopics, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n","import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"PostOpRevertReason\" event.\n */\nexport type PostOpRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the PostOpRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { postOpRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  postOpRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function postOpRevertReasonEvent(\n  filters: PostOpRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event PostOpRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n","import { concat } from \"viem\";\nimport { isHex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  UserOperationV06,\n  UserOperationV06Hexed,\n  UserOperationV07,\n  UserOperationV07Hexed,\n} from \"../types.js\";\n\nexport const generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport const randomNonce = () => {\n  return BigInt(\n    concat([numberToHex(generateRandomUint192()), \"0x0000000000000000\"]),\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(\n  userOp: UserOperationV06 | UserOperationV07,\n): UserOperationV06Hexed | UserOperationV07Hexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      val === undefined || val === null || isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationV06Hexed | UserOperationV07Hexed;\n}\n","import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport { postOpRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport {\n  type BundlerOptions,\n  type EstimationResult,\n  type GasPriceResult,\n  type PmTransactionData,\n  type UserOperationReceipt,\n  type UserOperationV06,\n  type UserOperationV07,\n  formatUserOperationReceipt,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: hexToBigInt(res.verificationGas),\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n    paymasterVerificationGasLimit:\n      res.paymasterVerificationGasLimit !== undefined\n        ? hexToBigInt(res.paymasterVerificationGasLimit)\n        : undefined,\n    paymasterPostOpGasLimit:\n      res.paymasterPostOpGasLimit !== undefined\n        ? hexToBigInt(res.paymasterPostOpGasLimit)\n        : undefined,\n  };\n}\n\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<TransactionReceipt | undefined> {\n  const res = await getUserOpReceiptRaw(args);\n\n  if (!res) {\n    return undefined;\n  }\n\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent(), postOpRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(\n        `UserOp failed at txHash: ${res.receipt.transactionHash}`,\n      );\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.receipt.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<UserOperationReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    options: args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  return formatUserOperationReceipt(res as UserOperationReceipt);\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const entryPointVersion = getEntryPointVersion(\n    options.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n  const bundlerVersion = entryPointVersion === \"v0.6\" ? \"v1\" : \"v2\";\n  const bundlerUrl =\n    options.bundlerUrl ?? getDefaultBundlerUrl(options.chain, bundlerVersion);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = JSON.stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n","import type { Address } from \"abitype\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\n\nexport type SmartWalletOptions = Prettify<\n  {\n    chain: Chain; // TODO consider making default chain optional\n    factoryAddress?: string;\n    overrides?: {\n      bundlerUrl?: string;\n      accountAddress?: string;\n      accountSalt?: string;\n      entrypointAddress?: string;\n      erc20Paymaster?: {\n        address: string;\n        token: string;\n      };\n      paymaster?: (\n        userOp: UserOperationV06 | UserOperationV07,\n      ) => Promise<PaymasterResult>;\n      predictAddress?: (factoryContract: ThirdwebContract) => Promise<string>;\n      createAccount?: (\n        factoryContract: ThirdwebContract,\n      ) => PreparedTransaction;\n      execute?: (\n        accountContract: ThirdwebContract,\n        transaction: SendTransactionOption,\n      ) => PreparedTransaction;\n      executeBatch?: (\n        accountContract: ThirdwebContract,\n        transactions: SendTransactionOption[],\n      ) => PreparedTransaction;\n      getAccountNonce?: (accountContract: ThirdwebContract) => Promise<bigint>;\n    };\n  } & (\n    | {\n        /**\n         * @deprecated use 'sponsorGas' instead\n         */\n        gasless: boolean;\n      }\n    | {\n        sponsorGas: boolean;\n      }\n  )\n>;\n\n// internal type\nexport type SmartAccountOptions = Prettify<\n  Omit<SmartWalletOptions, \"chain\" | \"gasless\" | \"sponsorGas\"> & {\n    chain: Chain;\n    sponsorGas: boolean;\n    personalAccount: Account;\n    factoryContract: ThirdwebContract;\n    accountContract: ThirdwebContract;\n    client: ThirdwebClient;\n  }\n>;\n\nexport type BundlerOptions = {\n  bundlerUrl?: string;\n  entrypointAddress?: string;\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\nexport type SmartWalletConnectionOptions = {\n  personalAccount: Account;\n  client: ThirdwebClient;\n  chain?: Chain;\n};\n\nexport type UserOperationV06 = {\n  sender: Address;\n  nonce: bigint;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07 = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  factory: string | undefined; // address\n  factoryData: Hex; // bytes\n  callData: Hex; // bytes\n  callGasLimit: bigint; // uint256\n  verificationGasLimit: bigint; // uint256\n  preVerificationGas: bigint; // uint256\n  maxFeePerGas: bigint; // uint256\n  maxPriorityFeePerGas: bigint; // uint256\n  paymaster: string | undefined; // address\n  paymasterData: Hex; // bytes\n  paymasterVerificationGasLimit: bigint; // uint256\n  paymasterPostOpGasLimit: bigint; // uint256\n  signature: Hex; // bytes\n};\n\nexport type PackedUserOperation = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  initCode: Hex; // bytes\n  callData: Hex; // bytes\n  accountGasLimits: Hex; // bytes32\n  preVerificationGas: bigint; // uint256\n  gasFees: Hex; // bytes32\n  paymasterAndData: Hex; // bytes\n  signature: Hex; // bytes\n};\n\nexport type UserOperationV06Hexed = {\n  sender: Address;\n  nonce: Hex;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07Hexed = {\n  sender: Hex;\n  nonce: Hex;\n  factory: Hex;\n  factoryData: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymaster: Hex;\n  paymasterVerificationGasLimit: Hex;\n  paymasterPostOpGasLimit: Hex;\n  paymasterData: Hex;\n  signature: Hex;\n};\n\nexport type PaymasterResult = {\n  preVerificationGas?: bigint;\n  verificationGasLimit?: bigint;\n  callGasLimit?: bigint;\n} & (\n  | {\n      // v0.6 types\n      paymasterAndData: string;\n    }\n  | {\n      // v0.7 types\n      paymaster: string;\n      paymasterData: string;\n      paymasterVerificationGasLimit?: bigint;\n      paymasterPostOpGasLimit?: bigint;\n    }\n);\n\nexport type EstimationResult = {\n  preVerificationGas: bigint;\n  verificationGas: bigint;\n  verificationGasLimit: bigint;\n  callGasLimit: bigint;\n  // v0.7 types\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n};\n\nexport type GasPriceResult = {\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n};\n\nexport type PmTransactionData = {\n  paymaster: Address;\n  paymasterInput: Hex;\n};\n\nexport type UserOperationReceipt = {\n  receipt: TransactionReceipt;\n  logs: TransactionReceipt[\"logs\"];\n  userOpHash: Hex;\n  entryPoint: Address;\n  sender: Address;\n  nonce: bigint;\n  paymaster: Address;\n  actualGasUsed: bigint;\n  actualGasCost: bigint;\n  success: boolean;\n};\n\nexport function formatUserOperationReceipt(\n  userOpReceiptRaw: UserOperationReceipt,\n) {\n  const { receipt: transactionReceipt } = userOpReceiptRaw;\n\n  const receipt = {\n    ...transactionReceipt,\n    transactionHash: transactionReceipt.transactionHash,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex,\n    status: transactionReceipt.status,\n    type: transactionReceipt.type,\n  } as TransactionReceipt;\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n\n  const userOpReceipt = {\n    ...userOpReceiptRaw,\n    receipt,\n    userOpHash: userOpReceiptRaw.userOpHash,\n    actualGasCost: BigInt(userOpReceiptRaw.actualGasCost),\n    actualGasUsed: BigInt(userOpReceiptRaw.actualGasUsed),\n    nonce: BigInt(userOpReceiptRaw.nonce),\n  } as UserOperationReceipt;\n  return userOpReceipt;\n}\n","import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    logs,\n    abi: events.map((e) => e.abiEvent),\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n","import type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const extraData = stringToHex(accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, extraData],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract);\n  }\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, stringToHex(accountSalt ?? \"\")],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getNonce\" function.\n */\nexport type GetNonceParams = {\n  sender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"sender\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"uint192\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x35567e1a\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"sender\",\n  },\n  {\n    type: \"uint192\",\n    name: \"key\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n    name: \"nonce\",\n  },\n] as const;\n\n/**\n * Checks if the `getNonce` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getNonce` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetNonceSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetNonceSupported([\"0x...\"]);\n * ```\n */\nexport function isGetNonceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getNonce\" function.\n * @param options - The options for the getNonce function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonceParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonceParams({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonceParams(options: GetNonceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.sender, options.key]);\n}\n\n/**\n * Encodes the \"getNonce\" function into a Hex string with its parameters.\n * @param options - The options for the getNonce function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonce } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonce({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonce(options: GetNonceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetNonceParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getNonce function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetNonceResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetNonceResultResult(\"...\");\n * ```\n */\nexport function decodeGetNonceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getNonce\" function on the contract.\n * @param options - The options for the getNonce function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getNonce } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getNonce({\n *  contract,\n *  sender: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function getNonce(\n  options: BaseTransactionOptions<GetNonceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.sender, options.key],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"uint256\"; name: \"callGasLimit\" },\n      { type: \"uint256\"; name: \"verificationGasLimit\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"uint256\"; name: \"maxFeePerGas\" },\n      { type: \"uint256\"; name: \"maxPriorityFeePerGas\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xa6193531\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple\",\n    name: \"userOp\",\n    components: [\n      {\n        type: \"address\",\n        name: \"sender\",\n      },\n      {\n        type: \"uint256\",\n        name: \"nonce\",\n      },\n      {\n        type: \"bytes\",\n        name: \"initCode\",\n      },\n      {\n        type: \"bytes\",\n        name: \"callData\",\n      },\n      {\n        type: \"uint256\",\n        name: \"callGasLimit\",\n      },\n      {\n        type: \"uint256\",\n        name: \"verificationGasLimit\",\n      },\n      {\n        type: \"uint256\",\n        name: \"preVerificationGas\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxFeePerGas\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxPriorityFeePerGas\",\n      },\n      {\n        type: \"bytes\",\n        name: \"paymasterAndData\",\n      },\n      {\n        type: \"bytes\",\n        name: \"signature\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"bytes32\"; name: \"accountGasLimits\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"bytes32\"; name: \"gasFees\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x22cdde4c\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple\",\n    name: \"userOp\",\n    components: [\n      {\n        type: \"address\",\n        name: \"sender\",\n      },\n      {\n        type: \"uint256\",\n        name: \"nonce\",\n      },\n      {\n        type: \"bytes\",\n        name: \"initCode\",\n      },\n      {\n        type: \"bytes\",\n        name: \"callData\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"accountGasLimits\",\n      },\n      {\n        type: \"uint256\",\n        name: \"preVerificationGas\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"gasFees\",\n      },\n      {\n        type: \"bytes\",\n        name: \"paymasterAndData\",\n      },\n      {\n        type: \"bytes\",\n        name: \"signature\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n","import { type Hex, concat, pad, slice, toHex } from \"viem\";\nimport type { PackedUserOperation, UserOperationV07 } from \"../types.js\";\n\nexport function getInitCode(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.factory\n    ? concat([\n        unpackedUserOperation.factory as Hex,\n        unpackedUserOperation.factoryData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nexport function getAccountGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(unpackedUserOperation.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(unpackedUserOperation.callGasLimit), { size: 16 }),\n  ]) as Hex;\n}\n\nexport function unpackAccountGasLimits(accountGasLimits: Hex) {\n  return {\n    verificationGasLimit: BigInt(slice(accountGasLimits, 0, 16)),\n    callGasLimit: BigInt(slice(accountGasLimits, 16)),\n  };\n}\n\nexport function getGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(unpackedUserOperation.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(unpackedUserOperation.maxFeePerGas), { size: 16 }),\n  ]) as Hex;\n}\n\nexport function unpackGasLimits(gasLimits: Hex) {\n  return {\n    maxPriorityFeePerGas: BigInt(slice(gasLimits, 0, 16)),\n    maxFeePerGas: BigInt(slice(gasLimits, 16)),\n  };\n}\n\nexport function getPaymasterAndData(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.paymaster\n    ? concat([\n        unpackedUserOperation.paymaster as Hex,\n        pad(\n          toHex(\n            unpackedUserOperation.paymasterVerificationGasLimit || BigInt(0),\n          ),\n          {\n            size: 16,\n          },\n        ),\n        pad(toHex(unpackedUserOperation.paymasterPostOpGasLimit || BigInt(0)), {\n          size: 16,\n        }),\n        unpackedUserOperation.paymasterData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nexport const getPackedUserOperation = (\n  userOperation: UserOperationV07,\n): PackedUserOperation => {\n  return {\n    sender: userOperation.sender,\n    nonce: userOperation.nonce,\n    initCode: getInitCode(userOperation),\n    callData: userOperation.callData,\n    accountGasLimits: getAccountGasLimits(userOperation),\n    preVerificationGas: userOperation.preVerificationGas,\n    gasFees: getGasLimits(userOperation),\n    paymasterAndData: getPaymasterAndData(userOperation),\n    signature: userOperation.signature,\n  };\n};\n","import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport type {\n  PaymasterResult,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Get paymaster and data details for a user operation.\n * @param args - The userOp and options\n * @returns - The paymaster and data details for the user operation.\n * @example\n * ```ts\n * import { getPaymasterAndData } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const paymasterAndData = await getPaymasterAndData({\n *  userOp,\n *  client,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  client: ThirdwebClient;\n  chain: Chain;\n  entrypointAddress?: string;\n  paymasterOverride?: (\n    userOp: UserOperationV06 | UserOperationV07,\n  ) => Promise<PaymasterResult>;\n}): Promise<PaymasterResult> {\n  const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;\n\n  if (paymasterOverride) {\n    return paymasterOverride(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const entrypoint = entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n  const entrypointVersion = getEntryPointVersion(entrypoint);\n  const paymasterVersion = entrypointVersion === \"v0.6\" ? \"v1\" : \"v2\";\n  const paymasterUrl = getDefaultBundlerUrl(chain, paymasterVersion);\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n      paymaster: res.result.paymaster,\n      paymasterData: res.result.paymasterData,\n      paymasterVerificationGasLimit: res.result.paymasterVerificationGasLimit\n        ? hexToBigInt(res.result.paymasterVerificationGasLimit)\n        : undefined,\n      paymasterPostOpGasLimit: res.result.paymasterPostOpGasLimit\n        ? hexToBigInt(res.result.paymasterPostOpGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n","import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  estimateUserOpGas,\n  getUserOpGasFees,\n  getUserOpReceipt,\n} from \"./bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareCreateAccount,\n  prepareExecute,\n} from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  ENTRYPOINT_ADDRESS_v0_7,\n  getDefaultAccountFactory,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\n\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n    timeoutMs?: number;\n    intervalMs?: number;\n  },\n): Promise<TransactionReceipt> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args: {\n  transaction: PreparedTransaction;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n\n  const bundlerOptions = {\n    client,\n    chain,\n    entrypointAddress: overrides?.entrypointAddress,\n  };\n\n  const entrypointVersion = getEntryPointVersion(\n    args.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  const [isDeployed, callData, gasFees, nonce] = await Promise.all([\n    isContractDeployed(accountContract),\n    encode(executeTx),\n    getGasFees({\n      executeTx,\n      bundlerOptions,\n      chain,\n      client,\n    }),\n    getAccountNonce({\n      accountContract,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      getNonceOverride: overrides?.getAccountNonce,\n    }),\n  ]);\n\n  const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;\n\n  if (entrypointVersion === \"v0.7\") {\n    return populateUserOp_v0_7({\n      bundlerOptions,\n      factoryContract,\n      accountContract,\n      adminAddress,\n      sponsorGas,\n      overrides,\n      isDeployed,\n      nonce,\n      callData,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    });\n  }\n\n  // default to v0.6\n  return populateUserOp_v0_6({\n    bundlerOptions,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    isDeployed,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  });\n}\n\nasync function getGasFees(args: {\n  executeTx: PreparedTransaction;\n  bundlerOptions: BundlerOptions;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<{\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}> {\n  const { executeTx, bundlerOptions, chain, client } = args;\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n\n  const entrypointVersion = getEntryPointVersion(\n    bundlerOptions.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n  const bundlerVersion = entrypointVersion === \"v0.6\" ? \"v1\" : \"v2\";\n  const bundlerUrl =\n    bundlerOptions?.bundlerUrl ?? getDefaultBundlerUrl(chain, bundlerVersion);\n\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n  return { maxFeePerGas, maxPriorityFeePerGas };\n}\n\nasync function populateUserOp_v0_7(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}): Promise<UserOperationV07> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  } = args;\n  const { chain, client } = bundlerOptions;\n  const factory = isDeployed ? undefined : factoryContract.address;\n  const factoryData = isDeployed\n    ? \"0x\"\n    : await encode(\n        prepareCreateAccount({\n          factoryContract: factoryContract,\n          adminAddress,\n          accountSalt: overrides?.accountSalt,\n          createAccountOverride: overrides?.createAccount,\n        }),\n      );\n\n  const partialOp: UserOperationV07 = {\n    sender: accountContract.address,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    factory,\n    factoryData,\n    paymaster: undefined,\n    paymasterData: \"0x\",\n    paymasterVerificationGasLimit: 0n,\n    paymasterPostOpGasLimit: 0n,\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = (await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    })) as Extract<PaymasterResult, { paymaster: string }>;\n    if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n      partialOp.paymaster = paymasterResult.paymaster;\n      partialOp.paymasterData = paymasterResult.paymasterData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas &&\n      paymasterResult.paymasterPostOpGasLimit &&\n      paymasterResult.paymasterVerificationGasLimit\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit || 0n;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit || 0n;\n      // need paymaster to re-sign after estimates\n      const paymasterResult2 = (await getPaymasterAndData({\n        userOp: partialOp,\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        paymasterOverride: overrides?.paymaster,\n      })) as Extract<PaymasterResult, { paymaster: string }>;\n      if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n        partialOp.paymaster = paymasterResult2.paymaster;\n        partialOp.paymasterData = paymasterResult2.paymasterData as Hex;\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n    partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n    partialOp.paymasterVerificationGasLimit =\n      estimates.paymasterVerificationGasLimit || 0n;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\nasync function populateUserOp_v0_6(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}): Promise<UserOperationV06> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  } = args;\n  const { chain, client } = bundlerOptions;\n  const initCode = isDeployed\n    ? \"0x\"\n    : await getAccountInitCode({\n        factoryContract: factoryContract,\n        adminAddress,\n        accountSalt: overrides?.accountSalt,\n        createAccountOverride: overrides?.createAccount,\n      });\n\n  const partialOp: UserOperationV06 = {\n    sender: accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    });\n    const paymasterAndData =\n      \"paymasterAndData\" in paymasterResult\n        ? paymasterResult.paymasterAndData\n        : \"0x\";\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster,\n        });\n        const paymasterAndData2 =\n          \"paymasterAndData\" in paymasterResult2\n            ? paymasterResult2.paymasterAndData\n            : \"0x\";\n        if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n          partialOp.paymasterAndData = paymasterAndData2 as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args: {\n  client: ThirdwebClient;\n  userOp: UserOperationV06 | UserOperationV07;\n  chain: Chain;\n  entrypointAddress?: string;\n  adminAccount: Account;\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const { userOp, chain, entrypointAddress, adminAccount } = args;\n\n  const entrypointVersion = getEntryPointVersion(\n    entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  let userOpHash: Hex;\n\n  if (entrypointVersion === \"v0.7\") {\n    const packedUserOp = getPackedUserOperation(userOp as UserOperationV07);\n    userOpHash = await getUserOpHashV07({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n        chain,\n        client: args.client,\n      }),\n      userOp: packedUserOp,\n    });\n  } else {\n    userOpHash = await getUserOpHashV06({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n        chain,\n        client: args.client,\n      }),\n      userOp: userOp as UserOperationV06,\n    });\n  }\n\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): Promise<Hex> {\n  const { factoryContract, adminAddress, accountSalt, createAccountOverride } =\n    options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\nasync function getAccountNonce(options: {\n  accountContract: ThirdwebContract;\n  chain: Chain;\n  client: ThirdwebClient;\n  entrypointAddress?: string;\n  getNonceOverride?: (accountContract: ThirdwebContract) => Promise<bigint>;\n}) {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride,\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client,\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address,\n  });\n}\n\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n}) {\n  const config = options.smartWalletOptions;\n  const factoryContract = getContract({\n    address:\n      config.factoryAddress ||\n      getDefaultAccountFactory(config.overrides?.entrypointAddress),\n    chain: config.chain,\n    client: options.client,\n  });\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: options.adminAccount.address,\n    predictAddressOverride: config.overrides?.predictAddress,\n    accountSalt: config.overrides?.accountSalt,\n    accountAddress: config.overrides?.accountAddress,\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain: config.chain,\n    client: options.client,\n  });\n\n  let executeTx: PreparedTransaction;\n  if (options.transactions.length === 1) {\n    const tx = options.transactions[0] as PreparedTransaction;\n    const serializedTx = await toSerializableTransaction({\n      transaction: tx,\n    });\n    executeTx = prepareExecute({\n      accountContract,\n      transaction: serializedTx,\n      executeOverride: config.overrides?.execute,\n    });\n  } else {\n    const serializedTxs = await Promise.all(\n      options.transactions.map((tx) =>\n        toSerializableTransaction({\n          transaction: tx,\n        }),\n      ),\n    );\n    executeTx = prepareBatchExecute({\n      accountContract,\n      transactions: serializedTxs,\n      executeBatchOverride: config.overrides?.executeBatch,\n    });\n  }\n\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract,\n    accountContract,\n    adminAddress: options.adminAccount.address,\n    sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n    overrides: config.overrides,\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: config.chain,\n    adminAccount: options.adminAccount,\n    entrypointAddress: config.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  return signedUserOp;\n}\n","import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n  maxUint96,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { concatHex } from \"../../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { getDefaultAccountFactory } from \"./lib/constants.js\";\nimport {\n  createUnsignedUserOp,\n  signUserOp,\n  waitForUserOpReceipt,\n} from \"./lib/userop.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"./types.js\";\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nexport const personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const factoryAddress =\n    options.factoryAddress ??\n    getDefaultAccountFactory(creationOptions.overrides?.entrypointAddress);\n  const chain = connectChain ?? options.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (isZkSyncChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: personalAccount.address,\n    predictAddressOverride: options.overrides?.predictAddress,\n    accountSalt: options.overrides?.accountSalt,\n    accountAddress: options.overrides?.accountAddress,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}: ${err?.message || \"unknown error\"}`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account: Account = {\n    address: getAddress(accountContract.address),\n    async sendTransaction(transaction: SendTransactionOption) {\n      // if erc20 paymaster - check allowance and approve if needed\n      const erc20Paymaster = options.overrides?.erc20Paymaster;\n      let paymasterOverride:\n        | undefined\n        | ((\n            userOp: UserOperationV06 | UserOperationV07,\n          ) => Promise<PaymasterResult>) = undefined;\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options,\n        });\n        const paymasterCallback = async (): Promise<PaymasterResult> => {\n          return {\n            paymasterAndData: concatHex([\n              erc20Paymaster.address as Hex,\n              erc20Paymaster?.token as Hex,\n            ]),\n            // for 0.7 compatibility\n            paymaster: erc20Paymaster.address as Hex,\n            paymasterData: \"0x\",\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      }\n      const executeTx = prepareExecute({\n        accountContract,\n        transaction,\n        executeOverride: options.overrides?.execute,\n      });\n      return _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride,\n          },\n        },\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        transactions,\n        executeBatchOverride: options.overrides?.executeBatch,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n  };\n  return account;\n}\n\nasync function approveERC20(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  erc20Paymaster: {\n    address: string;\n    token: string;\n  };\n}) {\n  const { accountContract, erc20Paymaster, options } = args;\n  const tokenAddress = erc20Paymaster.token;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client,\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.address,\n  });\n\n  if (accountAllowance > 0n) {\n    return;\n  }\n\n  const approveTx = approve({\n    contract: tokenContract,\n    spender: erc20Paymaster.address,\n    amountWei: maxUint96 - 1n,\n  });\n  const transaction = await toSerializableTransaction({\n    transaction: approveTx,\n    from: accountContract.address,\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    transaction,\n    executeOverride: options.overrides?.execute,\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        erc20Paymaster: undefined,\n      },\n    },\n  });\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            chain,\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          chain,\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract: options.factoryContract,\n    accountContract: options.accountContract,\n    adminAddress: options.personalAccount.address,\n    sponsorGas: options.sponsorGas,\n    overrides: options.overrides,\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: options.chain,\n    adminAccount: options.personalAccount,\n    entrypointAddress: options.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  const bundlerOptions: BundlerOptions = {\n    chain: options.chain,\n    client: options.client,\n    bundlerUrl: options.overrides?.bundlerUrl,\n    entrypointAddress: options.overrides?.entrypointAddress,\n  };\n  const userOpHash = await bundleUserOp({\n    options: bundlerOptions,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    ...options,\n    userOpHash,\n  });\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n","import type { Chain } from \"../../../chains/types.js\";\n\nexport function isZkSyncChain(chain: Chain) {\n  return (\n    chain.id === 324 ||\n    chain.id === 300 ||\n    chain.id === 302 ||\n    chain.id === 11124\n  );\n}\n","import type { OneOf, Pretty } from './types.js'\nimport { version } from './version.js'\n\ntype BaseErrorArgs = Pretty<\n  {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\n>\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n\n  override name = 'AbiTypeError'\n\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n          ? args.cause.message\n          : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: abitype@${version}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidAbiItemError extends BaseError {\n  override name = 'InvalidAbiItemError'\n\n  constructor({ signature }: { signature: string | object }) {\n    super('Failed to parse ABI item.', {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: '/api/human#parseabiitem-1',\n    })\n  }\n}\n\nexport class UnknownTypeError extends BaseError {\n  override name = 'UnknownTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [\n        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n      ],\n    })\n  }\n}\n\nexport class UnknownSolidityTypeError extends BaseError {\n  override name = 'UnknownSolidityTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n    })\n  }\n}\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\nimport type { Modifier } from '../types/signatures.js'\n\nexport class InvalidAbiParameterError extends BaseError {\n  override name = 'InvalidAbiParameterError'\n\n  constructor({ param }: { param: string | object }) {\n    super('Failed to parse ABI parameter.', {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: '/api/human#parseabiparameter-1',\n    })\n  }\n}\n\nexport class InvalidAbiParametersError extends BaseError {\n  override name = 'InvalidAbiParametersError'\n\n  constructor({ params }: { params: string | object }) {\n    super('Failed to parse ABI parameters.', {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: '/api/human#parseabiparameters-1',\n    })\n  }\n}\n\nexport class InvalidParameterError extends BaseError {\n  override name = 'InvalidParameterError'\n\n  constructor({ param }: { param: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n    })\n  }\n}\n\nexport class SolidityProtectedKeywordError extends BaseError {\n  override name = 'SolidityProtectedKeywordError'\n\n  constructor({ param, name }: { param: string; name: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n      ],\n    })\n  }\n}\n\nexport class InvalidModifierError extends BaseError {\n  override name = 'InvalidModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidFunctionModifierError extends BaseError {\n  override name = 'InvalidFunctionModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidAbiTypeParameterError extends BaseError {\n  override name = 'InvalidAbiTypeParameterError'\n\n  constructor({\n    abiParameter,\n  }: {\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\n  }) {\n    super('Invalid ABI parameter.', {\n      details: JSON.stringify(abiParameter, null, 2),\n      metaMessages: ['ABI parameter type is invalid.'],\n    })\n  }\n}\n","import type { AbiItemType } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\n\nexport class InvalidSignatureError extends BaseError {\n  override name = 'InvalidSignatureError'\n\n  constructor({\n    signature,\n    type,\n  }: {\n    signature: string\n    type: AbiItemType | 'struct'\n  }) {\n    super(`Invalid ${type} signature.`, {\n      details: signature,\n    })\n  }\n}\n\nexport class UnknownSignatureError extends BaseError {\n  override name = 'UnknownSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Unknown signature.', {\n      details: signature,\n    })\n  }\n}\n\nexport class InvalidStructSignatureError extends BaseError {\n  override name = 'InvalidStructSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Invalid struct signature.', {\n      details: signature,\n      metaMessages: ['No properties exist.'],\n    })\n  }\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : 'fallback()'\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback') return 'fallback()' as Result\n  return 'receive() external payable' as Result\n}\n","import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n","import type { AbiStateMutability } from '../../abi.js'\nimport { execTyped } from '../../regex.js'\nimport type {\n  EventModifier,\n  FunctionModifier,\n  Modifier,\n} from '../types/signatures.js'\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex =\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isErrorSignature(signature: string) {\n  return errorSignatureRegex.test(signature)\n}\nexport function execErrorSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    errorSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmoq\nconst eventSignatureRegex =\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isEventSignature(signature: string) {\n  return eventSignatureRegex.test(signature)\n}\nexport function execEventSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    eventSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmot\nconst functionSignatureRegex =\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\nexport function isFunctionSignature(signature: string) {\n  return functionSignatureRegex.test(signature)\n}\nexport function execFunctionSignature(signature: string) {\n  return execTyped<{\n    name: string\n    parameters: string\n    stateMutability?: AbiStateMutability\n    returns?: string\n  }>(functionSignatureRegex, signature)\n}\n\n// https://regexr.com/7gmp3\nconst structSignatureRegex =\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\nexport function isStructSignature(signature: string) {\n  return structSignatureRegex.test(signature)\n}\nexport function execStructSignature(signature: string) {\n  return execTyped<{ name: string; properties: string }>(\n    structSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/78u01\nconst constructorSignatureRegex =\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isConstructorSignature(signature: string) {\n  return constructorSignatureRegex.test(signature)\n}\nexport function execConstructorSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(constructorSignatureRegex, signature)\n}\n\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex =\n  /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isFallbackSignature(signature: string) {\n  return fallbackSignatureRegex.test(signature)\n}\n\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\nexport function isReceiveSignature(signature: string) {\n  return receiveSignatureRegex.test(signature)\n}\n\nexport const modifiers = new Set<Modifier>([\n  'memory',\n  'indexed',\n  'storage',\n  'calldata',\n])\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\nexport const functionModifiers = new Set<FunctionModifier>([\n  'calldata',\n  'memory',\n  'storage',\n])\n","import { BaseError } from '../../errors.js'\n\nexport class CircularReferenceError extends BaseError {\n  override name = 'CircularReferenceError'\n\n  constructor({ type }: { type: string }) {\n    super('Circular reference detected.', {\n      metaMessages: [`Struct \"${type}\" is a circular reference.`],\n    })\n  }\n}\n","import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\n  structs: StructLookup,\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n","import { BaseError } from '../../errors.js'\n\nexport class InvalidParenthesisError extends BaseError {\n  override name = 'InvalidParenthesisError'\n\n  constructor({ current, depth }: { current: string; depth: number }) {\n    super('Unbalanced parentheses.', {\n      metaMessages: [\n        `\"${current.trim()}\" has too many ${\n          depth > 0 ? 'opening' : 'closing'\n        } parentheses.`,\n      ],\n      details: `Depth \"${depth}\"`,\n    })\n  }\n}\n","import type { AbiItemType, AbiParameter } from '../../abi.js'\n\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(\n  param: string,\n  type?: AbiItemType | 'struct',\n) {\n  if (type) return `${type}:${param}`\n  return param\n}\n\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map<\n  string,\n  AbiParameter & { indexed?: boolean }\n>([\n  // Unnamed\n  ['address', { type: 'address' }],\n  ['bool', { type: 'bool' }],\n  ['bytes', { type: 'bytes' }],\n  ['bytes32', { type: 'bytes32' }],\n  ['int', { type: 'int256' }],\n  ['int256', { type: 'int256' }],\n  ['string', { type: 'string' }],\n  ['uint', { type: 'uint256' }],\n  ['uint8', { type: 'uint8' }],\n  ['uint16', { type: 'uint16' }],\n  ['uint24', { type: 'uint24' }],\n  ['uint32', { type: 'uint32' }],\n  ['uint64', { type: 'uint64' }],\n  ['uint96', { type: 'uint96' }],\n  ['uint112', { type: 'uint112' }],\n  ['uint160', { type: 'uint160' }],\n  ['uint192', { type: 'uint192' }],\n  ['uint256', { type: 'uint256' }],\n\n  // Named\n  ['address owner', { type: 'address', name: 'owner' }],\n  ['address to', { type: 'address', name: 'to' }],\n  ['bool approved', { type: 'bool', name: 'approved' }],\n  ['bytes _data', { type: 'bytes', name: '_data' }],\n  ['bytes data', { type: 'bytes', name: 'data' }],\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\n  ['string name', { type: 'string', name: 'name' }],\n  ['string symbol', { type: 'string', name: 'symbol' }],\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint8 v', { type: 'uint8', name: 'v' }],\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint256 value', { type: 'uint256', name: 'value' }],\n\n  // Indexed\n  [\n    'event:address indexed from',\n    { type: 'address', name: 'from', indexed: true },\n  ],\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n  [\n    'event:uint indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n  [\n    'event:uint256 indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n])\n","import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n    const inputParams = splitParameters(match.parameters)\n    const inputs = []\n    const inputLength = inputParams.length\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n\n    const outputs = []\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns)\n      const outputLength = outputParams.length\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i]!, {\n            modifiers: functionModifiers,\n            structs,\n            type: 'function',\n          }),\n        )\n      }\n    }\n\n    return {\n      name: match.name,\n      type: 'function',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs,\n      outputs,\n    }\n  }\n\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, {\n          modifiers: eventModifiers,\n          structs,\n          type: 'event',\n        }),\n      )\n    }\n    return { name: match.name, type: 'event', inputs: abiParameters }\n  }\n\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'error' }),\n      )\n    }\n    return { name: match.name, type: 'error', inputs: abiParameters }\n  }\n\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature)\n    if (!match)\n      throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n      )\n    }\n    return {\n      type: 'constructor',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs: abiParameters,\n    }\n  }\n\n  if (isFallbackSignature(signature)) return { type: 'fallback' }\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(param, options?.type)\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","export const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type InvalidAddressErrorType = InvalidAddressError & {\n  name: 'InvalidAddressError'\n}\nexport class InvalidAddressError extends BaseError {\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`, {\n      metaMessages: [\n        '- Address must be a hex value of 20 bytes (40 hex characters).',\n        '- Address must match its checksum counterpart.',\n      ],\n      name: 'InvalidAddressError',\n    })\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type NegativeOffsetErrorType = NegativeOffsetError & {\n  name: 'NegativeOffsetError'\n}\nexport class NegativeOffsetError extends BaseError {\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`, {\n      name: 'NegativeOffsetError',\n    })\n  }\n}\n\nexport type PositionOutOfBoundsErrorType = PositionOutOfBoundsError & {\n  name: 'PositionOutOfBoundsError'\n}\nexport class PositionOutOfBoundsError extends BaseError {\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n      { name: 'PositionOutOfBoundsError' },\n    )\n  }\n}\n\nexport type RecursiveReadLimitExceededErrorType =\n  RecursiveReadLimitExceededError & {\n    name: 'RecursiveReadLimitExceededError'\n  }\nexport class RecursiveReadLimitExceededError extends BaseError {\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n      { name: 'RecursiveReadLimitExceededError' },\n    )\n  }\n}\n","import { BaseError } from './base.js'\n\nexport type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {\n  name: 'SliceOffsetOutOfBoundsError'\n}\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n      { name: 'SliceOffsetOutOfBoundsError' },\n    )\n  }\n}\n\nexport type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {\n  name: 'SizeExceedsPaddingSizeError'\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n      { name: 'SizeExceedsPaddingSizeError' },\n    )\n  }\n}\n\nexport type InvalidBytesLengthErrorType = InvalidBytesLengthError & {\n  name: 'InvalidBytesLengthError'\n}\nexport class InvalidBytesLengthError extends BaseError {\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,\n      { name: 'InvalidBytesLengthError' },\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype TrimOptions = {\n  dir?: 'left' | 'right' | undefined\n}\nexport type TrimReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type TrimErrorType = ErrorType\n\nexport function trim<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir = 'left' }: TrimOptions = {},\n): TrimReturnType<value> {\n  let data: any =\n    typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (typeof hexOrBytes === 'string') {\n    if (data.length === 1 && dir === 'right') data = `${data}0`\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<value>\n  }\n  return data as TrimReturnType<value>\n}\n","import { InvalidBytesBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport {\n  type AssertSizeErrorType,\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  assertSize,\n  hexToBigInt,\n  hexToNumber,\n} from './fromHex.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type FromBytesParameters<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n> =\n  | to\n  | {\n      /** Size of the bytes. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromBytesReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'hex'\n    ? Hex\n    : to extends 'bigint'\n      ? bigint\n      : to extends 'number'\n        ? number\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromBytesErrorType =\n  | BytesToHexErrorType\n  | BytesToBigIntErrorType\n  | BytesToBoolErrorType\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(\n  bytes: ByteArray,\n  toOrOpts: FromBytesParameters<to>,\n): FromBytesReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number')\n    return bytesToNumber(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'bigint')\n    return bytesToBigInt(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'boolean')\n    return bytesToBool(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'string')\n    return bytesToString(bytes, opts) as FromBytesReturnType<to>\n  return bytesToHex(bytes, opts) as FromBytesReturnType<to>\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBigIntErrorType =\n  | BytesToHexErrorType\n  | HexToBigIntErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(\n  bytes: ByteArray,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToBigInt(hex, opts)\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBoolErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(\n  bytes_: ByteArray,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes)\n  }\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts\n\nexport type BytesToNumberErrorType =\n  | BytesToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(\n  bytes: ByteArray,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToNumber(hex, opts)\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToStringErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(\n  bytes_: ByteArray,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import type { AbiParameter, AbiParametersToPrimitiveTypes } from 'abitype'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceBytesErrorType, sliceBytes } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type BytesToBigIntErrorType,\n  type BytesToBoolErrorType,\n  type BytesToNumberErrorType,\n  type BytesToStringErrorType,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n} from '../encoding/fromBytes.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  params extends readonly AbiParameter[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  params extends readonly AbiParameter[] ? params : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | DecodeParameterErrorType\n  | SizeErrorType\n  | CreateCursorErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const params extends readonly AbiParameter[],\n>(\n  params: params,\n  data: ByteArray | Hex,\n): DecodeAbiParametersReturnType<params> {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data\n  const cursor = createCursor(bytes)\n\n  if (size(bytes) === 0 && params.length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data: typeof data === 'string' ? data : bytesToHex(data),\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n\n  let consumed = 0\n  const values = []\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i]\n    cursor.setPosition(consumed)\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    values.push(data)\n  }\n  return values as DecodeAbiParametersReturnType<params>\n}\n\ntype DecodeParameterErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeStringErrorType\n  | InvalidAbiDecodingTypeErrorType\n\nfunction decodeParameter(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(cursor, { ...param, type }, { length, staticPosition })\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, { staticPosition })\n\n  if (param.type === 'address') return decodeAddress(cursor)\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n// Type Decoders\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | BytesToHexErrorType\n  | SliceBytesErrorType\n  | ErrorType\n\nfunction decodeAddress(cursor: Cursor) {\n  const value = cursor.readBytes(32)\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32]\n}\n\ntype DecodeArrayErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeArray(\n  cursor: Cursor,\n  param: AbiParameter,\n  { length, staticPosition }: { length: number | null; staticPosition: number },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\ntype DecodeBoolErrorType = BytesToBoolErrorType | ErrorType\n\nfunction decodeBool(cursor: Cursor) {\n  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32]\n}\n\ntype DecodeBytesErrorType =\n  | BytesToNumberErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nfunction decodeBytes(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = bytesToNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [bytesToHex(data), 32]\n  }\n\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size), 32))\n  return [value, 32]\n}\n\ntype DecodeNumberErrorType =\n  | BytesToNumberErrorType\n  | BytesToBigIntErrorType\n  | ErrorType\n\nfunction decodeNumber(cursor: Cursor, param: AbiParameter) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256')\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? bytesToBigInt(value, { signed })\n      : bytesToNumber(value, { signed }),\n    32,\n  ]\n}\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeTupleErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeTuple(\n  cursor: Cursor,\n  param: TupleAbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\ntype DecodeStringErrorType =\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(\n  cursor: Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = bytesToNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = bytesToString(trim(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n","import type { AbiError } from 'abitype'\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmetic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as const\n\nexport const solidityError: AbiError = {\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n}\nexport const solidityPanic: AbiError = {\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint256',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n}\n","import type { Abi, ExtractAbiError } from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  AbiErrorSignatureNotFoundError,\n  type AbiErrorSignatureNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = { abi?: abi | undefined; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allErrorNames extends ContractErrorName<abi> = ContractErrorName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [errorName in allErrorNames]: {\n          abiItem: abi extends Abi\n            ? Abi extends abi\n              ? AbiItem\n              : ExtractAbiError<abi, errorName>\n            : AbiItem\n          args: ContractErrorArgs<abi, errorName>\n          errorName: errorName\n        }\n      }[allErrorNames]\n    >\n  : {\n      abiItem: AbiItem\n      args: readonly unknown[] | undefined\n      errorName: string\n    }\n\nexport type DecodeErrorResultErrorType =\n  | AbiDecodingZeroDataErrorType\n  | AbiErrorSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function decodeErrorResult<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeErrorResultParameters<abi>,\n): DecodeErrorResultReturnType<abi> {\n  const { abi, data } = parameters as DecodeErrorResultParameters\n\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...(abi || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args:\n      'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n        ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n        : undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<abi>\n}\n","import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  type NumberToHexErrorType,\n  type StringToHexErrorType,\n  boolToHex,\n  numberToHex,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { LruMap } from '../lru.js'\nimport { type IsAddressErrorType, isAddress } from './isAddress.js'\n\nconst checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)\n\nexport type ChecksumAddressErrorType =\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\nexport function checksumAddress(\n  address_: Address,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number | undefined,\n): Address {\n  if (checksumAddressCache.has(`${address_}.${chainId}`))\n    return checksumAddressCache.get(`${address_}.${chainId}`)!\n\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  const result = `0x${address.join('')}` as const\n  checksumAddressCache.set(`${address_}.${chainId}`, result)\n  return result\n}\n\nexport type GetAddressErrorType =\n  | ChecksumAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function getAddress(\n  address: string,\n  /**\n   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n   * that relies on EIP-55 checksum encoding (checksum without chainId).\n   *\n   * It is highly recommended to not use this feature unless you\n   * know what you are doing.\n   *\n   * See more: https://github.com/ethereum/EIPs/issues/1121\n   */\n  chainId?: number,\n): Address {\n  if (!isAddress(address, { strict: false }))\n    throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { LruMap } from '../lru.js'\nimport { checksumAddress } from './getAddress.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)\n\nexport type IsAddressOptions = {\n  /**\n   * Enables strict mode. Whether or not to compare the address against its checksum.\n   *\n   * @default true\n   */\n  strict?: boolean | undefined\n}\n\nexport type IsAddressErrorType = ErrorType\n\nexport function isAddress(\n  address: string,\n  options?: IsAddressOptions | undefined,\n): address is Address {\n  const { strict = true } = options ?? {}\n  const cacheKey = `${address}.${strict}`\n\n  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!\n\n  const result = (() => {\n    if (!addressRegex.test(address)) return false\n    if (address.toLowerCase() === address) return true\n    if (strict) return checksumAddress(address as Address) === address\n    return true\n  })()\n  isAddressCache.set(cacheKey, result)\n  return result\n}\n","import {\n  NegativeOffsetError,\n  type NegativeOffsetErrorType,\n  PositionOutOfBoundsError,\n  type PositionOutOfBoundsErrorType,\n  RecursiveReadLimitExceededError,\n  type RecursiveReadLimitExceededErrorType,\n} from '../errors/cursor.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ByteArray } from '../types/misc.js'\n\nexport type Cursor = {\n  bytes: ByteArray\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): ByteArray[number]\n  inspectBytes(length: number, position?: number): ByteArray\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: ByteArray[number]): void\n  pushBytes(bytes: ByteArray): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): ByteArray[number]\n  readBytes(length: number, size?: number): ByteArray\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\ntype CursorErrorType =\n  | CursorAssertPositionErrorType\n  | CursorDecrementPositionErrorType\n  | CursorIncrementPositionErrorType\n  | ErrorType\n\ntype CursorAssertPositionErrorType = PositionOutOfBoundsErrorType | ErrorType\n\ntype CursorDecrementPositionErrorType = NegativeOffsetError | ErrorType\n\ntype CursorIncrementPositionErrorType = NegativeOffsetError | ErrorType\n\ntype StaticCursorErrorType =\n  | NegativeOffsetErrorType\n  | RecursiveReadLimitExceededErrorType\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: ByteArray[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: ByteArray) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\ntype CursorConfig = { recursiveReadLimit?: number | undefined }\n\nexport type CreateCursorErrorType =\n  | CursorErrorType\n  | StaticCursorErrorType\n  | ErrorType\n\nexport function createCursor(\n  bytes: ByteArray,\n  { recursiveReadLimit = 8_192 }: CursorConfig = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<value extends Hex | ByteArray> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<value extends Hex | ByteArray>(\n  values: readonly value[],\n): ConcatReturnType<value> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<value>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<value>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(\n  value: bigint | number,\n  opts?: NumberToHexOpts | undefined,\n) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number | undefined\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n","import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n","import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Keccak256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function keccak256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Keccak256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<to>\n  return toHex(bytes) as Keccak256Hash<to>\n}\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","import { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize)\n      this.delete(this.keys().next().value)\n    return this\n  }\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain)\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') validateData(types[primaryType], message)\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\ntype HashStructErrorType = EncodeDataErrorType | Keccak256ErrorType | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n"],"names":["formatBlock","block","transactions","map","transaction","formatTransaction","baseFeePerGas","BigInt","blobGasUsed","undefined","difficulty","excessBlobGas","gasLimit","gasUsed","hash","logsBloom","nonce","number","size","timestamp","totalDifficulty","async","eth_getBlockByNumber","request","params","blockTag","includeTransactions","blockNumberHex","blockNumber","numberToHex","method","Error","eth_maxPriorityFeePerGas","result","hexToBigInt","getGasPrice","options","client","chain","percentMultiplier","rpcClient","getRpcClient","gasPrice_","eth_gasPrice","FORCE_GAS_PRICE_CHAIN_IDS","getGasOverridesForTransaction","maxFeePerGas","maxPriorityFeePerGas","gasPrice","Promise","all","resolvePromisedValue","defaultGasOverrides","getDefaultGasOverrides","experimental","increaseZeroByteCount","roundUpGas","includes","id","feeData","maxPriorityFeePerGas_","rpcRequest","catch","baseBlockFee","chainId","gasStationUrl","getGasStationUrl","priorityFee","fetch","json","fast","maxPriorityFee","fixedFee","Number","parseFloat","toFixed","toUnits","e","console","error","MIN_POLYGON_GAS_PRICE","getPolygonGasPriorityFee","defaultPriorityFeePerGas","arguments","length","extraTip","getPreferredPriorityFee","getDynamicFeeData","value","highestBit","encodeWeakMap","WeakMap","encode","has","get","promise","data","extraData","concatHex","getDataFromTx","getExtraCallDataFromTx","set","extraCallData","startsWith","rpcTransactionType","legacy","eip2930","eip1559","eip4844","eip7702","formatTransactionRequest","authorizationList","authorization","address","contractAddress","r","s","yParity","v","accessList","blobVersionedHashes","blobs","x","bytesToHex","from","gas","maxFeePerBlobGas","to","type","formatAbi","abi","signatures","i","abiItem","signature","formatAbiItem","push","FN_SELECTOR","FN_INPUTS","FN_OUTPUTS","components","name","DEFAULT_GATEWAY","download","url","uri","resolveArweaveScheme","gateway","config","storage","gatewayUrl","clientId","cid","firstIndex","search","slice","findIPFSCidFromUri","bundleId","globalThis","Application","applicationId","replace","split","resolveScheme","res","getClientFetch","keepalive","headers","requestTimeoutMs","ok","body","cancel","statusText","ALPHABET","BASE","LEADER","charAt","iFACTOR","Math","log","src","srcEnd","position","EMPTY_ARRAY","currentStructures","srcString","strings","stringPosition","currentDecoder","srcStringStart","bundledStrings","referenceMap","srcStringEnd","currentExtensions","packedValues","dataView","defaultOptions","useRecords","mapsAsObjects","Decoder","constructor","Object","assign","this","decodeKey","key","decode","source","end","DataView","buffer","byteOffset","byteLength","Uint8Array","sharedValues","pack","Array","maxPrivatePackedValues","concat","read","postBundlePosition","incomplete","RangeError","message","checkedRead","token","majorType","copyBuffers","prototype","call","subarray","string","shortStringInJS","start","bytes","byte","fromCharCode","apply","String","longStringInJS","decoder","units","byte1","byte2","byte3","unit","readFixedString","array","object","safeKey","isNaN","toString","a","b","c","d","f","g","h","j","k","l","m","n","o","glbl","RegExp","read_","Map","target","refEntry","targetProperties","used","mult10","floor","extractIPFSUri","bytecode","numericBytecode","hexToBytes","isHex","strict","ensureBytecodePrefix","cborLength","cborStart","bytecodeBuffer","cborData","TypeError","zeroes","pbegin","pend","b58","carry","it1","it2","str","repeat","base58Encode","ipfs","ABI_RESOLUTION_CACHE","resolveContractAbi","contract","contractApiBaseUrl","prom","response","resolveAbiFromContractApi","rootAbi","resolveSubAbi","rootAbi_","pluginPatternAddresses","baseRouterAddresses","modularExtensionAddresses","diamondFacetAddresses","resolveAbiFromBytecode","resolvePluginPatternAddresses","resolveBaseRouterAddresses","resolveModularModuleAddresses","resolveDiamondFacetAddresses","mergedPlugins","Set","pluginAbis","plugins","pluginAddress","newContract","getAbisForPlugins","flat","filter","item","Boolean","humanReadableAbi","structs","parseStructs","isStructSignature","parseSignature","parseAbi","joinAbis","resolveCompositeAbi","getBytecode","ipfsUri","output","PLUGINS_ABI","inputs","outputs","internalType","stateMutability","BASE_ROUTER_ABI","DIAMOND_ABI","readContract","pluginMap","metadata","implementation","modules","getInstalledModules","facets","facetAddress","extractError","args","errorObj","parsedError","decodeErrorResult","TransactionError","errorName","stringify","reason","super","defineProperty","cache","estimateGas","account","txWithFrom","predefinedGas","parseEstimationError","__contract","encodedData","toAddress","eth_estimateGas","toSerializableTransaction","resolvedNonce","then","_ref","eth_getTransactionCount","extraGas","toRlp","encodable","getEncodable","cursor","createCursor","isArray","list","bodyLength","reduce","acc","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","sizeOfBytesLength","pushBytes","getEncodableBytes","BaseError","toBigInt","isInteger","uint8ArrayToHex","Maj","HashMD","Hash","blockLen","outputLen","padOffset","isLE","finished","pos","destroyed","view","createView","update","exists","len","toBytes","take","min","process","roundClean","digestInto","out","fill","setBigUint64","_32n","_u32_max","wh","wl","setUint32","oview","outLen","state","digest","destroy","_cloneInto","SHA256_K","Uint32Array","SHA256_IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","rotr","s1","T1","T2","Chi","sha256","wrapConstructor","maxBytecodeSize","maxUint16","BytecodeLengthExceedsMaxSizeError","givenLength","BytecodeLengthInWordsMustBeOddError","_ref2","givenLengthInWords","BytecodeLengthMustBeDivisibleBy32Error","_ref3","hashBytecode","bytecodeBytes","hashStr","to_","noble_sha256","toHex","bytecodeLengthInWords","bytecodeLength","bytecodeLengthPadded","pad","codeHashVersion","gasPerPubdataDefault","getEip712Domain","paymaster","paymasterInput","gasPerPubdata","factoryDeps","txType","gasPerPubdataByteLimit","dep","transactionToMessage","domain","version","types","Transaction","primaryType","sendEip712Transaction","eip712Transaction","populateEip712Transaction","signEip712Transaction","rpc","transactionHash","signedTransaction","eth_sendRawTransaction","eip712Domain","customSignature","signTypedData","serializedTransaction","serializeTransactionEIP712","eip712","gas_limit","max_fee_per_gas","max_priority_fee_per_gas","gas_per_pubdata_limit","prepareTransaction","info","__preparedMethod","preparedMethod","resolvedPreparedMethod","resolvedParams","isAbiFunction","prepareMethod","parseAbiItem","abiFunction","find","resolvePreparedMethod","encodeAbiParameters","txRequest","stateOverrides","overrides","fromEntries","entries","override","balance","code","stateDiff","eth_call","decoded","decodeAbiParameters","values","preparedParams","prepareParam","param","prepareParams","encodeParams","arrayComponents","matches","match","getArrayComponents","dynamic","dynamicChild","preparedParam","length_","encoded","_ref4","encodeArray","_ref7","param_","_ref8","encodeTuple","encodeAddress","padHex","boolToHex","encodeBool","_ref6","signed","encodeNumber","_ref5","paramSize","bytesSize","byteSize","value_","dir","ceil","parseInt","encodeBytes","hexValue","stringToHex","partsLength","parts","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","isAddress","toLowerCase","prepareMethodCache","LruMap","abiFn","ret","toFunctionSelector","tokens","decimals","integerPart","fractionPart","prefix","padEnd","roundingDigit","roundedFraction","substring","padStart","prepareContractCall","rest","preparedMethodPromise","preparedM","approve","asyncOptions","fn","once","asyncParams","resolvedOptions","spender","erc20Value","generatedApprove","amount","amountWei","tokenAddress","parseTypedData","typedData","hexToNumber","toEventSelector","toSignatureHash","docsPath","decodeTopic","getAbiItem","parameters","isSelector","abiItems","matchedAbiItem","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AbiItemAmbiguityError","argType","abiParameterType","component","test","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","parseEventLogs","logs","eventName","topics","event","strict_","argTopics","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","isUnnamed","some","indexedInputs","indexed","topic","DecodeLogTopicsMismatch","nonIndexedInputs","decodedData","err","AbiDecodingDataSizeTooSmallError","PositionOutOfBoundsError","DecodeLogDataMismatch","decodeEventLog","matchArgs","isEqual","input","InvalidAddressError","isAddressEqual","keccak256","includesArgs","FilterTypeNotSupportedError","encodeEventTopics","AbiEventNotFoundError","definition","args_","_","encodeArg","prepareEvent","resolvedSignature","abiEvent","toEventHash","filters","userOperationRevertReasonEvent","postOpRevertReasonEvent","generateRandomUint192","rand1","random","rand2","rand3","rand4","rand5","rand6","hexlifyUserOp","userOp","val","estimateUserOpGas","sendBundlerRequest","operation","entrypointAddress","ENTRYPOINT_ADDRESS_v0_6","preVerificationGas","verificationGas","verificationGasLimit","callGasLimit","MANAGED_ACCOUNT_GAS_BUFFER","paymasterVerificationGasLimit","paymasterPostOpGasLimit","getUserOpReceipt","userOpHash","userOpReceiptRaw","receipt","transactionReceipt","cumulativeGasUsed","effectiveGasPrice","transactionIndex","status","blobGasPrice","actualGasCost","actualGasUsed","formatUserOperationReceipt","getUserOpReceiptRaw","success","events","viem_parseEventLogs","revertReason","revertMsg","join","DEBUG","debug","bundlerVersion","getEntryPointVersion","bundlerUrl","getDefaultBundlerUrl","fetchWithHeaders","jsonrpc","JSON","prepareCreateAccount","adminAddress","factoryContract","createAccountOverride","createAccount","accountSalt","prepareExecute","accountContract","executeOverride","execute","getAccountGasLimits","unpackedUserOperation","getGasLimits","getPaymasterAndData","paymasterData","getPackedUserOperation","userOperation","sender","initCode","factory","factoryData","callData","accountGasLimits","gasFees","paymasterAndData","paymasterOverride","entrypoint","paymasterVersion","paymasterUrl","createUnsignedUserOp","executeTx","sponsorGas","bundlerOptions","entrypointVersion","isDeployed","isContractDeployed","getGasFees","getAccountNonce","getNonceOverride","partialOp","DUMMY_SIGNATURE","paymasterResult","estimates","paymasterResult2","populateUserOp_v0_7","deployTx","getAccountInitCode","paymasterAndData2","populateUserOp_v0_6","isThirdwebUrl","bundlerGasPrice","getUserOpGasFees","resolvedMaxFeePerGas","resolvedMaxPriorityFeePerGas","signUserOp","adminAccount","packedUserOp","getUserOpHashV07","getContract","ENTRYPOINT_ADDRESS_v0_7","getUserOpHashV06","signMessage","raw","getNonce","personalAccountToSmartAccountMap","smartWalletToPersonalAccountMap","connectSmartWallet","wallet","connectionOptions","creationOptions","personalAccount","connectChain","factoryAddress","getDefaultAccountFactory","gasless","isZkSyncChain","createZkSyncAccount","accountAddress","predictAddressOverride","predictAddress","cause","getAddress","sendTransaction","erc20Paymaster","tokenContract","accountAllowance","owner","allowance","approveTx","maxUint96","_sendUserOp","approveERC20","paymasterCallback","sendBatchTransaction","executeBatchOverride","executeBatch","tx","prepareBatchExecute","hashMessage","checkContractWalletSignature","_deployAccount","originalMsgHash","sig","factorySupports712","wrappedMessageHash","verifyingContract","AccountMessage","_typedData","checkContractWalletSignedTypedData","hashTypedData","onTransactionRequested","createSmartAccount","disconnectSmartWallet","delete","prepTx","getCachedChain","serializableTransaction","pmData","getZkPaymasterData","txHash","broadcastZkTransaction","dummyTx","unsignedUserOp","signedUserOp","bundleUserOp","timeout","timeoutMs","interval","intervalMs","endtime","Date","now","userOpReceipt","resolve","setTimeout","waitForUserOpReceipt","shortMessage","details","metaMessages","InvalidAbiItemError","UnknownTypeError","UnknownSolidityTypeError","InvalidParameterError","SolidityProtectedKeywordError","InvalidModifierError","modifier","InvalidFunctionModifierError","InvalidAbiTypeParameterError","InvalidSignatureError","UnknownSignatureError","InvalidStructSignatureError","tupleRegex","formatAbiParameter","execTyped","formatAbiParameters","abiParameters","signature_","errorSignatureRegex","isErrorSignature","execErrorSignature","eventSignatureRegex","isEventSignature","execEventSignature","functionSignatureRegex","isFunctionSignature","execFunctionSignature","structSignatureRegex","execStructSignature","constructorSignatureRegex","isConstructorSignature","execConstructorSignature","fallbackSignatureRegex","isFallbackSignature","receiveSignatureRegex","isReceiveSignature","eventModifiers","functionModifiers","CircularReferenceError","shallowStructs","signaturesLength","properties","propertiesLength","trimmed","trim","parseAbiParameter","resolvedStructs","entriesLength","resolveStructs","typeWithoutTupleRegex","ancestors","isTupleRegex","isSolidityType","InvalidParenthesisError","current","depth","parameterCache","inputParams","splitParameters","inputLength","modifiers","returns","outputParams","outputLength","abiParameterWithoutTupleRegex","abiParameterWithTupleRegex","dynamicIntegerRegex","parameterCacheKey","getParameterCacheKey","isTuple","bytesRegex","integerRegex","protectedKeywordsRegex","isSolidityKeyword","components_","isValidDataLocation","char","tail","regex","exec","groups","formatAbiParams","includeName","AbiDecodingZeroDataError","AbiEncodingArrayLengthMismatchError","expectedLength","AbiEncodingBytesSizeMismatchError","expectedSize","AbiEncodingLengthMismatchError","AbiErrorSignatureNotFoundError","_ref9","_ref10","_ref11","y","BytesSizeMismatchError","_ref14","givenSize","_ref15","_ref16","InvalidAbiEncodingTypeError","_ref17","InvalidAbiDecodingTypeError","_ref18","InvalidArrayError","InvalidDefinitionTypeError","NegativeOffsetError","RecursiveReadLimitExceededError","count","limit","SliceOffsetOutOfBoundsError","SizeExceedsPaddingSizeError","targetSize","toUpperCase","hexOrBytes","sliceLength","bytesToBigInt","opts","assertSize","hex","bytesToBool","bytes_","InvalidBytesBooleanError","bytesToNumber","bytesToString","TextDecoder","consumed","setPosition","consumed_","decodeParameter","staticPosition","readBytes","sizeOfOffset","startOfData","sizeOfLength","hasDynamicChild","decodeArray","hasUnnamedChild","decodeTuple","checksumAddress","sliceBytes","decodeAddress","decodeBool","decodeBytes","decodeNumber","decodeString","endsWith","solidityError","solidityPanic","formatAbiParam","checksumAddressCache","address_","hexAddress","stringToBytes","addressRegex","isAddressCache","cacheKey","staticCursor","ArrayBuffer","positionReadCount","recursiveReadCount","recursiveReadLimit","POSITIVE_INFINITY","assertReadLimit","assertPosition","decrementPosition","getReadCount","incrementPosition","inspectByte","position_","inspectBytes","inspectUint8","inspectUint16","getUint16","inspectUint24","getUint8","inspectUint32","setUint16","setUint8","readByte","_touch","readUint8","readUint16","readUint24","readUint32","remaining","oldPosition","create","arr","concatBytes","paddedBytes","padBytes","hex_","assertStartOffset","assertEndOffset","sliceHex","encoder","TextEncoder","numberToBytes","boolToBytes","charCodeMap","zero","nine","charCodeToBase16","hexString","nibbleLeft","charCodeAt","nibbleRight","hexes","_v","maxValue","MAX_SAFE_INTEGER","minValue","suffix","IntegerOutOfRangeError","max","keccak_256","toSignature","def","active","level","valid","normalizeSignature","maxSize","keys","next","getTypesForEIP712Domain","salt","EIP712Domain","validateData","struct","integerMatch","_type","base","size_","bytesMatch","validateTypedData","hashStruct","hashDomain","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","encodedHashType","unsortedDeps","findTypeDependencies","deps","sort","t","encodeType","primaryType_","results","add","lastIndexOf","parsedType","typeValuePairs"],"sourceRoot":""}